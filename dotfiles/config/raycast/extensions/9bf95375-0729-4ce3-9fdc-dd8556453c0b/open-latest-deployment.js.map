{
  "version": 3,
  "sources": ["../src/open-latest-deployment.ts", "../src/vercel.ts", "../src/utils/is-valid-token.ts"],
  "sourcesContent": ["import { getPreferenceValues, LocalStorage, open, openCommandPreferences, showToast, Toast } from \"@raycast/api\";\nimport { fetchLatestDeployment, fetchTeams, fetchUser, getDeploymentURL } from \"./vercel\";\nimport isValidToken from \"./utils/is-valid-token\";\n\nexport default async function Command() {\n  const toast = await showToast({\n    style: Toast.Style.Animated,\n    title: \"Loading latest deployment...\",\n  });\n\n  try {\n    await isValidToken();\n  } catch {\n    toast.style = Toast.Style.Failure;\n    toast.title = \"Invalid token\";\n    toast.message = \"Please set a valid Vercel access token in the settings.\";\n    toast.primaryAction = {\n      title: \"Open Settings\",\n      onAction: () => openCommandPreferences(),\n    };\n    return;\n  }\n\n  // Get the selected team from local storage\n  const selectedTeamId = await LocalStorage.getItem<string>(\"selectedTeamId\");\n\n  // Fetch user and teams in parallel\n  const [user, teams] = await Promise.all([fetchUser(), fetchTeams()]);\n\n  // Validate that the selected team still exists\n  let validTeamId = selectedTeamId;\n  if (selectedTeamId) {\n    const teamExists = teams.some((team) => team.id === selectedTeamId);\n    if (!teamExists) {\n      await LocalStorage.removeItem(\"selectedTeamId\");\n      validTeamId = undefined;\n    }\n  }\n\n  // Fetch the latest deployment\n  const deployment = await fetchLatestDeployment(validTeamId);\n\n  if (!deployment) {\n    toast.style = Toast.Style.Failure;\n    toast.title = \"No deployments found\";\n    toast.message = validTeamId ? \"No deployments found for the selected team.\" : \"No deployments found.\";\n    return;\n  }\n\n  // Determine which URL to open based on preferences\n  const preferences = getPreferenceValues<Preferences.OpenLatestDeployment>();\n  const openTarget = preferences.openTarget ?? \"vercel\";\n\n  let url: string;\n  if (openTarget === \"deployUrl\") {\n    url = `https://${deployment.url}`;\n  } else {\n    // Open Vercel Dashboard deployment page\n    const team = validTeamId ? teams.find((t) => t.id === validTeamId) : undefined;\n    const slugOrUsername = team?.slug || user.username;\n\n    // @ts-expect-error Property id does not exist on type Deployment (but it does in practice)\n    const deploymentId = deployment.id || deployment.uid;\n    url = getDeploymentURL(slugOrUsername, deployment.name, deploymentId);\n  }\n\n  toast.style = Toast.Style.Success;\n  toast.title = \"Opening deployment\";\n  toast.message = deployment.name;\n\n  await open(url);\n}\n", "import { environment, getPreferenceValues, showToast, Toast } from \"@raycast/api\";\nimport type {\n  Team,\n  Deployment,\n  Project,\n  Environment,\n  User,\n  CreateEnvironmentVariableResponse,\n  Build,\n  Pagination,\n  CreateEnvironment,\n  Domain,\n} from \"./types\";\n\nexport const token = getPreferenceValues().accessToken;\nconst headers = {\n  Authorization: \"Bearer \" + token,\n};\n\nexport const FetchHeaders = Object.entries(headers);\n\nconst apiURL = \"https://api.vercel.com/\";\n\n// Fetch the username that belongs to the token given.\n// Use for filtering deployments by user and providing links later on\nexport async function fetchUser(): Promise<User> {\n  try {\n    const response = await fetch(apiURL + \"www/user\", {\n      method: \"get\",\n      headers: headers,\n    });\n\n    const json = (await response.json()) as { user: User };\n\n    return json.user;\n  } catch (err) {\n    console.error(err);\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Failed to fetch user info\",\n    });\n    throw new Error(\"Failed to fetch user info\");\n  }\n}\n\n/*\n * Fetch all teams for user\n */\nexport async function fetchTeams(): Promise<Team[]> {\n  const response = await fetch(apiURL + \"v1/teams\", {\n    method: \"get\",\n    headers: headers,\n  });\n  const json = (await response.json()) as { teams: Team[] };\n  const teams: Team[] = [];\n  for (const team of json.teams) {\n    teams.push(team);\n  }\n  return teams;\n}\n\nexport async function deleteProjectById(projectId: Project[\"id\"], teamId?: Team[\"id\"]) {\n  try {\n    const response = await fetch(apiURL + `v8/projects/${projectId}?teamId=${teamId ?? \"\"}`, {\n      method: \"delete\",\n      headers: headers,\n    });\n    const json = (await response.json()) as { project: Project };\n    return json.project;\n  } catch (e) {\n    console.error(e);\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Failed to delete project\",\n    });\n    throw new Error(\"Failed to delete project\");\n  }\n}\n\nexport async function deleteEnvironmentVariableById(\n  projectId: Project[\"id\"],\n  envId: Environment[\"id\"],\n): Promise<Environment> {\n  try {\n    const response = await fetch(apiURL + `v8/projects/${projectId}/env/${envId}`, {\n      method: \"delete\",\n      headers: headers,\n    });\n    const json = (await response.json()) as { environment: Environment };\n    return json.environment;\n  } catch (e) {\n    console.error(e);\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Failed to delete environment variable\",\n    });\n    throw new Error(\"Failed to delete environment variable\");\n  }\n}\n\nexport function getFetchDeploymentsURL(teamId?: string, projectId?: string, limit = 100) {\n  const url = apiURL + `v6/deployments`;\n\n  let query = `?limit=${limit}&teamId=${teamId ?? \"\"}`;\n  if (projectId) {\n    query += `&projectId=${projectId}`;\n  }\n\n  return url + query;\n}\n\nexport async function fetchDeployments(teamId?: string, limit = 100, maxToFetch = 300) {\n  try {\n    const fetchURL = getFetchDeploymentsURL(teamId, undefined, limit);\n    const response = await fetch(fetchURL, {\n      method: \"get\",\n      headers: headers,\n    });\n    const json = (await response.json()) as { deployments: Deployment[]; pagination: Pagination };\n\n    // eslint-disable-next-line prefer-const\n    let { deployments, pagination } = json;\n\n    while (pagination?.next && deployments.length < maxToFetch) {\n      const next = await fetch(fetchURL + \"&until=\" + pagination.next, {\n        method: \"get\",\n        headers: headers,\n      });\n      const nextJson = (await next.json()) as { deployments: Deployment[]; pagination: Pagination };\n      pagination = nextJson.pagination;\n      json.deployments.push(...nextJson.deployments);\n    }\n\n    return json.deployments;\n  } catch (err) {\n    console.error(err);\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Failed to fetch deployments\",\n    });\n    throw new Error(\"Failed to fetch deployments\");\n  }\n}\n\nexport async function fetchLatestDeployment(teamId?: string): Promise<Deployment | null> {\n  try {\n    const fetchURL = getFetchDeploymentsURL(teamId, undefined, 1);\n    const response = await fetch(fetchURL, {\n      method: \"get\",\n      headers: headers,\n    });\n    const json = (await response.json()) as { deployments: Deployment[] };\n    return json.deployments[0] ?? null;\n  } catch (err) {\n    console.error(err);\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Failed to fetch latest deployment\",\n    });\n    throw new Error(\"Failed to fetch latest deployment\");\n  }\n}\n\nexport function getFetchDeploymentBuildsURL(\n  deploymentId: Deployment[\"uid\"] | string,\n  teamId?: Team[\"id\"],\n  limit = 100,\n) {\n  return apiURL + `v11/deployments/${deploymentId}/builds?limit=${limit}&teamId=${teamId ?? \"\"}`;\n}\n\nexport async function fetchDeploymentBuildsByDeploymentId(deploymentId: string, teamId?: string, limit?: number) {\n  try {\n    const response = await fetch(getFetchDeploymentBuildsURL(deploymentId, teamId, limit), {\n      method: \"get\",\n      headers: headers,\n    });\n    const json = (await response.json()) as { builds: Build[] };\n    return json.builds;\n  } catch (err) {\n    console.error(err);\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Failed to fetch deployment builds\",\n    });\n    throw new Error(\"Failed to fetch deployment builds\");\n  }\n}\n\n// Fetch project environment variable\nexport async function fetchEnvironmentVariables(projectId: string, teamId?: string): Promise<Environment[]> {\n  const environmentVariables: Environment[] = [...(await _rawFetchProjectEnvironmentVariables(projectId, teamId))];\n  return environmentVariables.sort((a, b) => b.updatedAt - a.updatedAt);\n}\n\nexport function getFetchProjectsURL(teamId?: string, limit = 100) {\n  return apiURL + `v8/projects?teamId=${teamId ?? \"\"}&limit=${limit}`;\n}\n\nexport async function fetchProjects(teamId?: string, limit = 100): Promise<Project[]> {\n  const response = await fetch(getFetchProjectsURL(teamId, limit), {\n    method: \"get\",\n    headers: headers,\n  });\n  const json = (await response.json()) as { projects: Project[] };\n  return json.projects;\n}\n\n// Raw function for fetching project environment variable\nasync function _rawFetchProjectEnvironmentVariables(projectId: string, teamId?: string): Promise<Environment[]> {\n  try {\n    const response = await fetch(apiURL + `v8/projects/${projectId}/env?teamId=${teamId ?? \"\"}`, {\n      method: \"get\",\n      headers: headers,\n    });\n    const json = (await response.json()) as { envs: Environment[] };\n\n    return json.envs;\n  } catch (err) {\n    console.error(err);\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Failed to fetch environment variable\",\n    });\n    throw new Error(\"Failed to fetch environment variable\");\n  }\n}\n\n// Update project environment variable\nexport async function updateEnvironmentVariable(\n  projectId: Project[\"id\"],\n  envId: Environment[\"id\"],\n  envVar: Partial<Environment>,\n): Promise<Environment> {\n  const environmentVariable: Environment = await _rawUpdateProjectEnvironmentVariable(projectId, envId, envVar);\n  return environmentVariable;\n}\n\n// TODO: use Omit<>\nexport async function createEnvironmentVariable(\n  projectId: Project[\"id\"],\n  envVar: CreateEnvironment,\n  teamId?: Team[\"id\"],\n): Promise<CreateEnvironmentVariableResponse> {\n  envVar[\"type\"] = \"encrypted\";\n\n  try {\n    const response = await fetch(apiURL + `v9/projects/${projectId}/env?teamId=${teamId ? teamId : \"\"}`, {\n      method: \"post\",\n      headers: headers,\n      body: JSON.stringify(envVar),\n    });\n    const json = (await response.json()) as CreateEnvironmentVariableResponse;\n    return json;\n  } catch (e) {\n    console.error(e);\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Failed to create environment variable\",\n    });\n    throw new Error(\"Failed to create environment variable\");\n  }\n}\n\nasync function _rawUpdateProjectEnvironmentVariable(\n  projectId: Project[\"id\"],\n  envId: Environment[\"id\"],\n  envVar: Partial<Environment>,\n): Promise<Environment> {\n  try {\n    const response = await fetch(apiURL + `v8/projects/${projectId}/env/${envId}`, {\n      method: \"patch\",\n      headers: headers,\n      body: JSON.stringify(envVar),\n    });\n    const environmentVariable = (await response.json()) as Environment;\n    return environmentVariable;\n  } catch (err) {\n    console.error(err);\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Failed to fetch environment variable\",\n    });\n    throw new Error(\"Failed to fetch environment variable\");\n  }\n}\n\nfunction arrayBufferToBase64(buffer: ArrayBuffer) {\n  let binary = \"\";\n  const bytes = [].slice.call(new Uint8Array(buffer));\n\n  bytes.forEach((b) => (binary += String.fromCharCode(b)));\n\n  return btoa(binary);\n}\n\nexport async function getScreenshotImageURL(deploymentId: Deployment[\"uid\"], teamId?: string) {\n  try {\n    const theme = environment.appearance === \"light\" ? \"0\" : \"1\";\n    const response = await fetch(\n      `https://vercel.com/api/screenshot?dark=${theme}&deploymentId=${deploymentId}&withStatus=false&teamId=${teamId ?? \"\"}`,\n      {\n        method: \"get\",\n        headers: headers,\n      },\n    );\n\n    if (response.status !== 200) {\n      return null;\n    }\n\n    const arrayBuffer = await response.arrayBuffer();\n    const base64Flag = \"data:image/png;base64,\";\n    const imageStr = base64Flag + arrayBufferToBase64(arrayBuffer);\n    return imageStr;\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n}\n\nexport function getDeploymentURL(userOrTeamSlug: string, projectName: string, deploymentId: Deployment[\"uid\"]) {\n  if (deploymentId.startsWith(\"dpl_\")) {\n    deploymentId = deploymentId.substring(4);\n  }\n\n  return `https://vercel.com/${userOrTeamSlug}/${projectName}/${deploymentId}`;\n}\n\nexport function getFetchDomainsURL(teamId?: string, limit = 100) {\n  return apiURL + `v5/domains?teamId=${teamId ?? \"\"}&limit=${limit}`;\n}\n\nexport async function fetchDomains(teamId?: string, limit = 100) {\n  const response = await fetch(getFetchDomainsURL(teamId, limit), {\n    method: \"get\",\n    headers: headers,\n  });\n  const json = (await response.json()) as { domains: Domain[] };\n  return json.domains;\n}\n\nexport async function checkDomainAvailability(domain: string) {\n  const response = await fetch(apiURL + `v1/registrar/domains/${domain}/availability`, {\n    method: \"get\",\n    headers: headers,\n  });\n\n  if (!response.ok) {\n    const errorJson = (await response.json()) as { code: string; message: string };\n    return {\n      available: false,\n      error:\n        errorJson.message ||\n        \"Check domain availability failed. Please verify that the domain is valid or try again later.\",\n    };\n  }\n\n  const json = (await response.json()) as { available: boolean };\n  return { available: json.available };\n}\n", "import { fetchUser } from \"../vercel\";\n\nconst isValidToken = async () => {\n  const user = await fetchUser();\n  if (!user) throw new Error(\"Failed to fetch user data. Token may be invalid.\");\n  return true;\n};\n\nexport default isValidToken;\n"],
  "mappings": "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",
  "names": ["open_latest_deployment_exports", "__export", "Command", "__toCommonJS", "import_api", "import_api", "token", "headers", "FetchHeaders", "apiURL", "fetchUser", "err", "fetchTeams", "json", "teams", "team", "getFetchDeploymentsURL", "teamId", "projectId", "limit", "url", "apiURL", "query", "fetchLatestDeployment", "teamId", "fetchURL", "getFetchDeploymentsURL", "headers", "err", "getDeploymentURL", "userOrTeamSlug", "projectName", "deploymentId", "isValidToken", "fetchUser", "is_valid_token_default", "Command", "toast", "is_valid_token_default", "selectedTeamId", "user", "teams", "fetchUser", "fetchTeams", "validTeamId", "team", "deployment", "fetchLatestDeployment", "openTarget", "url", "slugOrUsername", "t", "deploymentId", "getDeploymentURL"]
}
