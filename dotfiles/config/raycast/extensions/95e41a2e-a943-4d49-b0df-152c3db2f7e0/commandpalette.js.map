{
  "version": 3,
  "sources": ["../src/commandpalette.tsx", "../src/lib/vscode.ts", "../src/lib/utils.ts", "../src/utils/editor.ts", "../node_modules/cache-func/dist/index.js", "../src/lib/preferences.ts"],
  "sourcesContent": ["import { Action, ActionPanel, Icon, List, popToRoot, showHUD, showToast, Toast } from \"@raycast/api\";\nimport * as afs from \"fs/promises\";\nimport * as os from \"os\";\nimport path from \"path\";\nimport { useEffect, useState } from \"react\";\nimport { getBuildNamePreference, getBuildScheme } from \"./lib/vscode\";\nimport {\n  fileExists,\n  getErrorMessage,\n  isWin,\n  openURIinVSCode,\n  raycastForVSCodeURI,\n  waitForFileExists,\n} from \"./lib/utils\";\n\ninterface CommandMetadata {\n  command: string;\n  title: string;\n  category?: string;\n}\n\nfunction transitFolder(): string {\n  const build = getBuildNamePreference();\n\n  let ts = path.join(os.homedir(), `Library/Application Support/${build}/User/globalStorage/tonka3000.raycast/transit`);\n\n  if (isWin) {\n    ts = path.join(os.homedir(), `AppData/Roaming/${build}/User/globalStorage/tonka3000.raycast/transit`);\n  }\n  return ts;\n}\n\nfunction CreateCommandQuickLinkAction(props: { command: CommandMetadata }) {\n  const c = props.command;\n  const title = c.category ? `${c.category}: ${c.title}` : c.title;\n  return (\n    <Action.CreateQuicklink\n      shortcut={{ modifiers: [\"cmd\"], key: \"l\" }}\n      quicklink={{ link: raycastForVSCodeURI(`runcommand?cmd=${c.command}`), name: `VSCode - ${title}` }}\n    />\n  );\n}\n\nasync function getCommandFromVSCode() {\n  const tsFolder = transitFolder();\n  await afs.mkdir(tsFolder, { recursive: true });\n  const requestFilename = path.join(tsFolder, \"request.json\");\n  const responseFilename = path.join(tsFolder, \"commands.json\");\n  await afs.writeFile(\n    requestFilename,\n    JSON.stringify(\n      {\n        command: \"writecommands\",\n        args: {\n          filename: responseFilename,\n        },\n      },\n      null,\n      2,\n    ),\n  );\n  if (await fileExists(responseFilename)) {\n    await afs.rm(responseFilename);\n  }\n  if (await waitForFileExists(responseFilename)) {\n    const cmds = await readCommandsFile(responseFilename);\n    return cmds;\n  }\n  throw new Error(\"Could not get VSCode commands\");\n}\n\nfunction CommandListItem(props: { command: CommandMetadata }) {\n  const c = props.command;\n  const title = (c: CommandMetadata) => {\n    if (c.category) {\n      return `${c.category}: ${c.title}`;\n    } else {\n      return c.title;\n    }\n  };\n  const handle = async () => {\n    try {\n      await openURIinVSCode(`runcommand?cmd=${c.command}`);\n      popToRoot();\n    } catch (error) {\n      showToast({ style: Toast.Style.Failure, title: \"Could not run Command\", message: getErrorMessage(error) });\n    }\n  };\n  return (\n    <List.Item\n      title={title(c)}\n      actions={\n        <ActionPanel>\n          <ActionPanel.Section>\n            <Action title=\"Run Command\" onAction={handle} icon={{ source: Icon.Terminal }} />\n            <CreateCommandQuickLinkAction command={c} />\n          </ActionPanel.Section>\n          <ActionPanel.Section>\n            <Action.CopyToClipboard\n              shortcut={{ modifiers: [\"cmd\", \"shift\"], key: \".\" }}\n              title=\"Copy Command ID\"\n              content={c.command}\n            />\n          </ActionPanel.Section>\n        </ActionPanel>\n      }\n    />\n  );\n}\n\nfunction InstallRaycastForVSCodeAction() {\n  return (\n    <Action.OpenInBrowser\n      title=\"Install Raycast for VS Code\"\n      url={`${getBuildScheme()}:extension/tonka3000.raycast`}\n      onOpen={() => {\n        popToRoot();\n        showHUD(\"Open VSCode Extension\");\n      }}\n    />\n  );\n}\n\nexport default function CommandPaletteCommand() {\n  const { isLoading, commands, error, refresh } = useCommands();\n  if (error) {\n    showToast({ style: Toast.Style.Failure, title: \"Error\", message: error });\n  }\n  return (\n    <List\n      isLoading={isLoading}\n      searchBarPlaceholder={isLoading === true ? \"Load Commands from VSCode\" : \"Search Commands\"}\n    >\n      <List.Section title=\"Commands\" subtitle={`${commands?.length}`}>\n        {commands?.map((c) => (\n          <CommandListItem key={c.command} command={c} />\n        ))}\n      </List.Section>\n      {error && (\n        <List.EmptyView\n          title=\"No Response from Raycast for VSCode extension\"\n          description=\"Please ensure the Raycast for VSCode extension is installed and running\"\n          icon=\"\u26A0\uFE0F\"\n          actions={\n            <ActionPanel>\n              <Action\n                title=\"Reload\"\n                icon={Icon.RotateClockwise}\n                shortcut={{ modifiers: [\"cmd\"], key: \"r\" }}\n                onAction={refresh}\n              />\n              <InstallRaycastForVSCodeAction />\n            </ActionPanel>\n          }\n        />\n      )}\n    </List>\n  );\n}\n\nasync function readCommandsFile(filename: string): Promise<CommandMetadata[] | undefined> {\n  const data = await afs.readFile(filename, \"utf-8\");\n  const result = JSON.parse(data) as CommandMetadata[] | undefined;\n  await afs.rm(filename);\n  return result;\n}\n\nfunction useCommands(): {\n  commands: CommandMetadata[] | undefined;\n  isLoading?: boolean;\n  error?: string;\n  refresh?: () => void;\n} {\n  const [isLoading, setIsLoading] = useState(true);\n  const [commands, setCommands] = useState<CommandMetadata[]>();\n  const [error, setError] = useState<string>();\n  const [date, setDate] = useState(new Date());\n\n  const refresh = () => {\n    setDate(new Date());\n  };\n\n  useEffect(() => {\n    let didUnmount = false;\n    async function fetchCommands() {\n      if (didUnmount) {\n        return;\n      }\n      setIsLoading(true);\n      setError(undefined);\n      try {\n        const cmds = await getCommandFromVSCode();\n        if (!didUnmount) {\n          setCommands(cmds);\n        }\n      } catch (error) {\n        if (!didUnmount) {\n          setError(getErrorMessage(error));\n        }\n      } finally {\n        if (!didUnmount) {\n          setIsLoading(false);\n        }\n      }\n    }\n    fetchCommands();\n    return () => {\n      didUnmount = true;\n    };\n  }, [date]);\n\n  return { commands, isLoading, error, refresh };\n}\n", "import { getPreferenceValues, open } from \"@raycast/api\";\nimport * as child_process from \"child_process\";\nimport * as afs from \"fs/promises\";\nimport * as os from \"os\";\nimport path from \"path\";\nimport { fileExists, isMac, isWin } from \"./utils\";\nimport { getEditorApplication } from \"../utils/editor\";\nimport { build } from \"./preferences\";\n\ninterface ExtensionMetaRoot {\n  identifier: ExtensionIdentifier;\n  version: string;\n  location: ExtensionLocation | string;\n  metadata?: ExtensionMetadata;\n}\n\ninterface ExtensionIdentifier {\n  id: string;\n  uuid: string;\n}\n\ninterface ExtensionLocation {\n  $mid: number;\n  fsPath: string;\n  path: string;\n  scheme: string;\n}\n\ninterface ExtensionMetadata {\n  id: string;\n  publisherId?: string;\n  publisherDisplayName?: string;\n  targetPlatform?: string;\n  isApplicationScoped?: boolean;\n  updated?: boolean;\n  isPreReleaseVersion: boolean;\n  installedTimestamp?: number;\n  preRelease?: boolean;\n}\n\nexport interface Extension {\n  id: string;\n  name: string;\n  version: string;\n  preRelease?: boolean;\n  icon?: string;\n  updated?: boolean;\n  fsPath: string;\n  publisherId?: string;\n  publisherDisplayName?: string;\n  preview?: boolean;\n  installedTimestamp?: number;\n}\n\ninterface PackageJSONInfo {\n  displayName?: string;\n  icon?: string;\n  preview?: boolean;\n}\n\nfunction getNLSVariable(text: string | undefined): string | undefined {\n  if (!text) {\n    return text;\n  }\n  const m = text.match(/%(.+)%/);\n  if (m) {\n    return m[1];\n  }\n}\nfunction cliPaths(): Record<string, string> {\n  let cliPaths: Record<string, string> = {};\n\n  if (isWin) {\n    const programsFolder = path.join(os.homedir(), \"AppData\", \"Local\", \"Programs\");\n    cliPaths = {\n      Antigravity: path.join(programsFolder, \"Antigravity\", \"bin\", \"antigravity.cmd\"),\n      Code: path.join(programsFolder, \"Microsoft VS Code\", \"bin\", \"code.cmd\"),\n      \"Code - Insiders\": path.join(programsFolder, \"Microsoft VS Code Insiders\", \"bin\", \"code-insiders.cmd\"),\n      Kiro: path.join(programsFolder, \"Kiro\", \"bin\", \"kiro.cmd\"),\n      Cursor: path.join(programsFolder, \"cursor\", \"resources\", \"app\", \"bin\", \"cursor.cmd\"),\n      Positron: path.join(programsFolder, \"Positron\", \"bin\", \"positron.cmd\"),\n      Trae: path.join(programsFolder, \"Trae\", \"bin\", \"trae.cmd\"),\n      \"Trae CN\": path.join(programsFolder, \"Trae CN\", \"bin\", \"trae-cn.cmd\"),\n      VSCodium: path.join(programsFolder, \"VSCodium\", \"bin\", \"codium.cmd\"),\n      \"VSCodium - Insiders\": path.join(programsFolder, \"VSCodium Insiders\", \"bin\", \"codium-insiders.cmd\"),\n      Windsurf: path.join(programsFolder, \"Windsurf\", \"bin\", \"windsurf.cmd\"),\n    };\n  }\n\n  if (isMac) {\n    cliPaths = {\n      Antigravity: \"/Applications/Antigravity.app/Contents/Resources/app/bin/antigravity\",\n      Code: \"/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code\",\n      \"Code - Insiders\": \"/Applications/Visual Studio Code - Insiders.app/Contents/Resources/app/bin/code\",\n      Cursor: \"/Applications/Cursor.app/Contents/Resources/app/bin/cursor\", // it also has code, which is an alias\n      Kiro: \"/Applications/Kiro.app/Contents/Resources/app/bin/kiro\",\n      Positron: \"/Applications/Positron.app/Contents/Resources/app/bin/code\",\n      Trae: \"/Applications/Trae.app/Contents/Resources/app/bin/marscode\",\n      \"Trae CN\": \"/Applications/Trae CN.app/Contents/Resources/app/bin/marscode\",\n      VSCodium: \"/Applications/VSCodium.app/Contents/Resources/app/bin/codium\",\n      \"VSCodium - Insiders\": \"/Applications/VSCodium - Insiders.app/Contents/Resources/app/bin/codium-insiders\",\n      Windsurf: \"/Applications/Windsurf.app/Contents/Resources/app/bin/windsurf\",\n    };\n  }\n\n  return cliPaths;\n}\n\nexport function getVSCodeCLIFilename(): string {\n  const cliPathsMac = cliPaths();\n  const name = cliPathsMac[getBuildNamePreference()];\n  if (!name || name.length <= 0) {\n    return cliPathsMac.Code;\n  }\n  return name;\n}\n\nexport class VSCodeCLI {\n  private cliFilename: string;\n  private execOptions: child_process.ExecFileOptions | undefined;\n  constructor(cliFilename: string) {\n    this.cliFilename = `\"${cliFilename}\"`;\n    this.execOptions = isWin ? { shell: true } : undefined;\n  }\n\n  installExtensionByIDSync(id: string) {\n    child_process.execFileSync(this.cliFilename, [\"--install-extension\", id, \"--force\"], this.execOptions);\n  }\n\n  uninstallExtensionByIDSync(id: string) {\n    child_process.execFileSync(this.cliFilename, [\"--uninstall-extension\", id, \"--force\"], this.execOptions);\n  }\n\n  async newWindow() {\n    const editorApp = await getEditorApplication(build);\n    open(\"\", editorApp);\n  }\n}\n\nexport function getVSCodeCLI(): VSCodeCLI {\n  return new VSCodeCLI(getVSCodeCLIFilename());\n}\n\nasync function getPackageJSONInfo(filename: string): Promise<PackageJSONInfo | undefined> {\n  try {\n    if (await fileExists(filename)) {\n      const packageJSONData = await afs.readFile(filename, { encoding: \"utf-8\" });\n      const packageJSON = JSON.parse(packageJSONData);\n      let displayName = packageJSON.displayName as string | undefined;\n      const nlsVariable = getNLSVariable(displayName);\n      const iconFilename = packageJSON.icon as string | undefined;\n      const folder = path.dirname(filename);\n      if (nlsVariable && nlsVariable.length > 0) {\n        const nlsFilename = path.join(folder, \"package.nls.json\");\n        try {\n          if (await fileExists(nlsFilename)) {\n            const nlsContent = await afs.readFile(nlsFilename, { encoding: \"utf-8\" });\n            const nlsJSON = JSON.parse(nlsContent);\n            const displayNameNLS = nlsJSON[nlsVariable] as string | undefined;\n            if (displayNameNLS && displayNameNLS.length > 0) {\n              displayName = displayNameNLS;\n            }\n          }\n        } catch {\n          // ignore\n        }\n      }\n      const preview = packageJSON.preview as boolean | undefined;\n      const icon = iconFilename ? path.join(folder, iconFilename) : undefined;\n      return {\n        displayName,\n        icon,\n        preview,\n      };\n    }\n  } catch {\n    //\n  }\n}\n\nexport async function getLocalExtensions(): Promise<Extension[] | undefined> {\n  const extensionsRootFolder = path.join(os.homedir(), `.${getBuildScheme()}/extensions`);\n  const extensionsManifrestFilename = path.join(extensionsRootFolder, \"extensions.json\");\n  if (await fileExists(extensionsManifrestFilename)) {\n    const data = await afs.readFile(extensionsManifrestFilename, { encoding: \"utf-8\" });\n    const extensions = JSON.parse(data) as ExtensionMetaRoot[] | undefined;\n    if (extensions && extensions.length > 0) {\n      const result: Extension[] = [];\n      for (const e of extensions) {\n        const extFsPath =\n          typeof e.location === \"string\"\n            ? path.join(extensionsRootFolder, e.location)\n            : (e.location.fsPath ?? e.location.path);\n        const packageFilename = path.join(extFsPath, \"package.json\");\n        const pkgInfo = await getPackageJSONInfo(packageFilename);\n        result.push({\n          id: e.identifier.id,\n          name: pkgInfo?.displayName || e.identifier.id,\n          version: e.version,\n          preRelease: e.metadata?.preRelease,\n          icon: pkgInfo?.icon,\n          updated: e.metadata?.updated,\n          fsPath: extFsPath,\n          publisherId: e.metadata?.publisherId,\n          publisherDisplayName: e.metadata?.publisherDisplayName,\n          preview: pkgInfo?.preview,\n          installedTimestamp: e.metadata?.installedTimestamp,\n        });\n      }\n      return result;\n    }\n  }\n  return undefined;\n}\n\nexport function getBuildNamePreference(): string {\n  const prefs = getPreferenceValues();\n  const build = prefs.build as string;\n  return build;\n}\n\nconst buildSchemes: Record<string, string> = {\n  Antigravity: \"antigravity\",\n  Code: \"vscode\",\n  \"Code - Insiders\": \"vscode-insiders\",\n  Cursor: \"cursor\",\n  Kiro: \"kiro\",\n  VSCodium: \"vscode-oss\",\n  Positron: \"positron\",\n  Windsurf: \"windsurf\",\n  Trae: \"trae\",\n  \"Trae CN\": \"trae-cn\",\n};\n\nexport function getBuildScheme(): string {\n  const scheme = buildSchemes[getBuildNamePreference()] as string | undefined;\n  if (!scheme || scheme.length <= 0) {\n    return buildSchemes.Code;\n  }\n  return scheme;\n}\n", "import { open } from \"@raycast/api\";\nimport * as fs from \"fs\";\nimport { existsSync } from \"fs\";\nimport { URL } from \"url\";\nimport { isDeepStrictEqual } from \"util\";\nimport { getBuildScheme } from \"./vscode\";\nimport {\n  EntryLike,\n  EntryType,\n  FileEntry,\n  FolderEntry,\n  RemoteEntry,\n  RemoteWorkspaceEntry,\n  WorkspaceEntry,\n} from \"./types\";\n\n// Type Guards\n\nexport function isFileEntry(entry: EntryLike): entry is FileEntry {\n  const { fileUri } = entry as FileEntry;\n\n  if (fileUri === undefined) {\n    return false;\n  }\n\n  try {\n    const fileUrl = new URL(fileUri);\n    return existsSync(fileUrl) && fileUri.indexOf(\".code-workspace\") === -1;\n  } catch {\n    return false;\n  }\n}\n\nexport function isFolderEntry(entry: EntryLike): entry is FolderEntry {\n  const { folderUri } = entry as FolderEntry;\n\n  if (folderUri === undefined) {\n    return false;\n  }\n\n  try {\n    const folderUrl = new URL(folderUri);\n    return existsSync(folderUrl);\n  } catch {\n    return false;\n  }\n}\n\nexport function isWorkspaceEntry(entry: EntryLike): entry is WorkspaceEntry {\n  const { workspace } = entry as WorkspaceEntry;\n\n  if (workspace === undefined) {\n    return false;\n  }\n\n  try {\n    const configUrl = new URL(workspace.configPath);\n    return existsSync(configUrl) && workspace.configPath.indexOf(\".code-workspace\") !== -1;\n  } catch {\n    return false;\n  }\n}\n\nexport function isRemoteEntry(entry: EntryLike): entry is RemoteEntry {\n  const { folderUri, remoteAuthority } = entry as RemoteEntry;\n  return folderUri !== undefined && remoteAuthority !== undefined;\n}\n\nexport function isRemoteWorkspaceEntry(entry: EntryLike): entry is RemoteWorkspaceEntry {\n  const { workspace, remoteAuthority } = entry as RemoteWorkspaceEntry;\n  return workspace !== undefined && remoteAuthority !== undefined;\n}\n\nexport function isSameEntry(a: EntryLike, b: EntryLike) {\n  if (\"fileUri\" in a && \"fileUri\" in b) {\n    return a.fileUri === b.fileUri;\n  }\n\n  if (\"folderUri\" in a && \"folderUri\" in b) {\n    return a.folderUri === b.folderUri;\n  }\n\n  if (\"workspace\" in a && \"workspace\" in b) {\n    return a.workspace.configPath === b.workspace.configPath;\n  }\n\n  return false;\n}\n\n// Filters\n\nexport function filterEntriesByType(filter: EntryType | null) {\n  switch (filter) {\n    case \"All Types\":\n      return () => true;\n    case \"Workspaces\":\n      return isWorkspaceEntry;\n    case \"Folders\":\n      return isFolderEntry;\n    case \"Remote Folders\":\n      return isRemoteEntry;\n    case \"Remote Workspace\":\n      return isRemoteWorkspaceEntry;\n    case \"Files\":\n      return isFileEntry;\n    default:\n      return () => false;\n  }\n}\n\nexport function filterUnpinnedEntries(pinnedEntries: EntryLike[]) {\n  return (entry: EntryLike) => pinnedEntries.find((pinnedEntry) => isDeepStrictEqual(pinnedEntry, entry)) === undefined;\n}\n\nexport function getErrorMessage(error: unknown): string {\n  return error instanceof Error ? error.message : \"unknown error\";\n}\n\nexport async function fileExists(filename: string): Promise<boolean> {\n  return fs.promises\n    .access(filename, fs.constants.F_OK)\n    .then(() => true)\n    .catch(() => false);\n}\n\nconst fmt = new Intl.NumberFormat(\"en\", { notation: \"compact\" });\n\nexport function compactNumberFormat(num: number): string {\n  return fmt.format(num);\n}\n\nexport function sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport async function waitForFileExists(filename: string, timeoutMs = 2000) {\n  const start = new Date();\n  while (start.getTime() > 0) {\n    await sleep(10);\n    if (await fileExists(filename)) {\n      return true;\n    }\n    const end = new Date();\n    const delta = end.getTime() - start.getTime();\n    if (delta > timeoutMs) {\n      return false;\n    }\n  }\n  return false;\n}\n\nexport function raycastForVSCodeURI(uri: string) {\n  return `${getBuildScheme()}://tonka3000.raycast/${uri}`;\n}\n\nexport async function openURIinVSCode(uri: string) {\n  await open(raycastForVSCodeURI(uri));\n}\n\nexport function isValidHexColor(color: string): boolean {\n  return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(color);\n}\n\nexport const isWin = process.platform === \"win32\";\nexport const isMac = process.platform === \"darwin\";\n", "import { Application, getApplications } from \"@raycast/api\";\nimport { cacheFunc } from \"cache-func\";\nimport { isMac } from \"../lib/utils\";\nimport path from \"path\";\n\nconst cachedGetApplications = cacheFunc(getApplications);\n\nconst bundleIdMap: Record<string, { macos: string; windows: { name: string; exe: string } }> = {\n  Antigravity: { macos: \"com.google.antigravity\", windows: { name: \"Antigravity\", exe: \"Antigravity.exe\" } },\n  Code: { macos: \"com.microsoft.VSCode\", windows: { name: \"Visual Studio Code\", exe: \"Code.exe\" } },\n  \"Code - Insiders\": {\n    macos: \"com.microsoft.VSCodeInsiders\",\n    windows: { name: \"Visual Studio Code - Insiders\", exe: \"Code - Insiders.exe\" },\n  },\n  Cursor: { macos: \"com.todesktop.230313mzl4w4u92\", windows: { name: \"Cursor\", exe: \"Cursor.exe\" } },\n  Kiro: { macos: \"dev.kiro.desktop\", windows: { name: \"Kiro\", exe: \"Kiro.exe\" } },\n  Positron: { macos: \"com.rstudio.positron\", windows: { name: \"Positron\", exe: \"Positron.exe\" } },\n  Trae: { macos: \"com.trae.app\", windows: { name: \"Trae\", exe: \"Trae.exe\" } },\n  \"Trae CN\": { macos: \"cn.trae.app\", windows: { name: \"Trae CN\", exe: \"Trae - CN.exe\" } },\n  VSCodium: { macos: \"com.vscodium\", windows: { name: \"VSCodium\", exe: \"VSCodium.exe\" } },\n  \"VSCodium - Insiders\": {\n    macos: \"com.vscodium.VSCodiumInsiders\",\n    windows: { name: \"VSCodium - Insiders\", exe: \"VSCodium - Insiders.exe\" },\n  },\n  Windsurf: { macos: \"com.exafunction.windsurf\", windows: { name: \"Windsurf\", exe: \"Windsurf.exe\" } },\n};\n\n/**\n * Get the application for the specified build name\n * @param buildName The name of the build (e.g., \"Code\", \"VSCodium\", etc.)\n * @returns Promise resolving to the Application object or undefined if not found\n */\nexport async function getEditorApplication(buildName: string): Promise<Application | undefined> {\n  const apps = await cachedGetApplications();\n\n  // Find the app by bundle ID\n  const bundleId = bundleIdMap[buildName];\n  if (isMac) {\n    if (bundleId) {\n      const app = apps.find((app) => app.bundleId === bundleId.macos);\n      if (app) return app;\n    }\n  } else {\n    const app = apps.find((app) => {\n      const isNameMatch = app.name === bundleId.windows.name;\n\n      const exeFromPath = path.basename(app.path);\n      const isExeMatch = exeFromPath === bundleId.windows.exe;\n\n      return isNameMatch || isExeMatch;\n    });\n    if (app) return app;\n  }\n\n  return undefined;\n}\n", "// src/index.ts\nfunction cacheFunc(fn, options) {\n  let val;\n  let lastRun;\n  function wrapper(...args) {\n    if (val === void 0 || options?.maxAge && lastRun !== void 0 && Date.now() - lastRun > options.maxAge) {\n      val = fn(...args);\n      lastRun = Date.now();\n    }\n    return val;\n  }\n  wrapper.clear = () => {\n    val = void 0;\n    lastRun = void 0;\n  };\n  return wrapper;\n}\nexport {\n  cacheFunc\n};\n", "import { getPreferenceValues } from \"@raycast/api\";\n\nconst preferences = getPreferenceValues<ExtensionPreferences>();\n\nexport const build = preferences.build;\nexport const layout = preferences.layout;\nexport const keepSectionOrder = preferences.keepSectionOrder;\nexport const closeOtherWindows = preferences.closeOtherWindows;\nexport const terminalApp = preferences.terminalApp;\nexport const showGitBranch = preferences.showGitBranch;\nexport const gitBranchColor = preferences.gitBranchColor;\n"],
  "mappings": "0jBAAA,IAAAA,GAAA,GAAAC,EAAAD,GAAA,aAAAE,IAAA,eAAAC,EAAAH,IAAA,IAAAI,EAAsF,wBACtFC,EAAqB,0BACrBC,EAAoB,iBACpBC,EAAiB,mBACjBC,EAAoC,iBCJpC,IAAAC,EAA0C,wBCA1C,IAAAC,EAAqB,wBACrBC,EAAoB,iBAiHb,SAASC,EAAgBC,EAAwB,CACtD,OAAOA,aAAiB,MAAQA,EAAM,QAAU,eAClD,CAEA,eAAsBC,EAAWC,EAAoC,CACnE,OAAU,WACP,OAAOA,EAAa,YAAU,IAAI,EAClC,KAAK,IAAM,EAAI,EACf,MAAM,IAAM,EAAK,CACtB,CAEA,IAAMC,GAAM,IAAI,KAAK,aAAa,KAAM,CAAE,SAAU,SAAU,CAAC,EAMxD,SAASC,EAAMC,EAAY,CAChC,OAAO,IAAI,QAASC,GAAY,WAAWA,EAASD,CAAE,CAAC,CACzD,CAEA,eAAsBE,EAAkBC,EAAkBC,EAAY,IAAM,CAC1E,IAAMC,EAAQ,IAAI,KAClB,KAAOA,EAAM,QAAQ,EAAI,GAAG,CAE1B,GADA,MAAMN,EAAM,EAAE,EACV,MAAMO,EAAWH,CAAQ,EAC3B,MAAO,GAIT,GAFY,IAAI,KAAK,EACH,QAAQ,EAAIE,EAAM,QAAQ,EAChCD,EACV,MAAO,EAEX,CACA,MAAO,EACT,CAEO,SAASG,EAAoBC,EAAa,CAC/C,MAAO,GAAGC,EAAe,CAAC,wBAAwBD,CAAG,EACvD,CAEA,eAAsBE,EAAgBF,EAAa,CACjD,QAAM,QAAKD,EAAoBC,CAAG,CAAC,CACrC,CAMO,IAAMG,EAAQ,QAAQ,WAAa,QAC7BC,EAAQ,QAAQ,WAAa,SCpK1C,IAAAC,EAA6C,wBCC7C,SAASC,EAAUC,EAAIC,EAAS,CAC9B,IAAIC,EACAC,EACJ,SAASC,KAAWC,EAAM,CACxB,OAAIH,IAAQ,QAAUD,GAAS,QAAUE,IAAY,QAAU,KAAK,IAAI,EAAIA,EAAUF,EAAQ,UAC5FC,EAAMF,EAAG,GAAGK,CAAI,EAChBF,EAAU,KAAK,IAAI,GAEdD,CACT,CACA,OAAAE,EAAQ,MAAQ,IAAM,CACpBF,EAAM,OACNC,EAAU,MACZ,EACOC,CACT,CDXA,IAAME,GAAwBC,EAAU,iBAAe,EELvD,IAAAC,EAAoC,wBAE9BC,KAAc,uBAA0C,EAEjDC,EAAQD,EAAY,MACpBE,GAASF,EAAY,OACrBG,GAAmBH,EAAY,iBAC/BI,GAAoBJ,EAAY,kBAChCK,GAAcL,EAAY,YAC1BM,GAAgBN,EAAY,cAC5BO,GAAiBP,EAAY,eJ6MnC,SAASQ,GAAiC,CAG/C,SAFc,uBAAoB,EACd,KAEtB,CAEA,IAAMC,EAAuC,CAC3C,YAAa,cACb,KAAM,SACN,kBAAmB,kBACnB,OAAQ,SACR,KAAM,OACN,SAAU,aACV,SAAU,WACV,SAAU,WACV,KAAM,OACN,UAAW,SACb,EAEO,SAASC,GAAyB,CACvC,IAAMC,EAASF,EAAaD,EAAuB,CAAC,EACpD,MAAI,CAACG,GAAUA,EAAO,QAAU,EACvBF,EAAa,KAEfE,CACT,CD5MI,IAAAC,EAAA,6BAfJ,SAASC,GAAwB,CAC/B,IAAMC,EAAQC,EAAuB,EAEjCC,EAAK,EAAAC,QAAK,KAAQ,UAAQ,EAAG,+BAA+BH,CAAK,+CAA+C,EAEpH,OAAII,IACFF,EAAK,EAAAC,QAAK,KAAQ,UAAQ,EAAG,mBAAmBH,CAAK,+CAA+C,GAE/FE,CACT,CAEA,SAASG,EAA6BC,EAAqC,CACzE,IAAMC,EAAID,EAAM,QACVE,EAAQD,EAAE,SAAW,GAAGA,EAAE,QAAQ,KAAKA,EAAE,KAAK,GAAKA,EAAE,MAC3D,SACE,OAAC,SAAO,gBAAP,CACC,SAAU,CAAE,UAAW,CAAC,KAAK,EAAG,IAAK,GAAI,EACzC,UAAW,CAAE,KAAME,EAAoB,kBAAkBF,EAAE,OAAO,EAAE,EAAG,KAAM,YAAYC,CAAK,EAAG,EACnG,CAEJ,CAEA,eAAeE,GAAuB,CACpC,IAAMC,EAAWZ,EAAc,EAC/B,MAAU,QAAMY,EAAU,CAAE,UAAW,EAAK,CAAC,EAC7C,IAAMC,EAAkB,EAAAT,QAAK,KAAKQ,EAAU,cAAc,EACpDE,EAAmB,EAAAV,QAAK,KAAKQ,EAAU,eAAe,EAiB5D,GAhBA,MAAU,YACRC,EACA,KAAK,UACH,CACE,QAAS,gBACT,KAAM,CACJ,SAAUC,CACZ,CACF,EACA,KACA,CACF,CACF,EACI,MAAMC,EAAWD,CAAgB,GACnC,MAAU,KAAGA,CAAgB,EAE3B,MAAME,EAAkBF,CAAgB,EAE1C,OADa,MAAMG,EAAiBH,CAAgB,EAGtD,MAAM,IAAI,MAAM,+BAA+B,CACjD,CAEA,SAASI,EAAgBX,EAAqC,CAC5D,IAAMC,EAAID,EAAM,QACVE,EAASD,GACTA,EAAE,SACG,GAAGA,EAAE,QAAQ,KAAKA,EAAE,KAAK,GAEzBA,EAAE,MAGPW,EAAS,SAAY,CACzB,GAAI,CACF,MAAMC,EAAgB,kBAAkBZ,EAAE,OAAO,EAAE,KACnD,aAAU,CACZ,OAASa,EAAO,IACd,aAAU,CAAE,MAAO,QAAM,MAAM,QAAS,MAAO,wBAAyB,QAASC,EAAgBD,CAAK,CAAE,CAAC,CAC3G,CACF,EACA,SACE,OAAC,OAAK,KAAL,CACC,MAAOZ,EAAMD,CAAC,EACd,WACE,QAAC,eACC,qBAAC,cAAY,QAAZ,CACC,oBAAC,UAAO,MAAM,cAAc,SAAUW,EAAQ,KAAM,CAAE,OAAQ,OAAK,QAAS,EAAG,KAC/E,OAACb,EAAA,CAA6B,QAASE,EAAG,GAC5C,KACA,OAAC,cAAY,QAAZ,CACC,mBAAC,SAAO,gBAAP,CACC,SAAU,CAAE,UAAW,CAAC,MAAO,OAAO,EAAG,IAAK,GAAI,EAClD,MAAM,kBACN,QAASA,EAAE,QACb,EACF,GACF,EAEJ,CAEJ,CAEA,SAASe,GAAgC,CACvC,SACE,OAAC,SAAO,cAAP,CACC,MAAM,8BACN,IAAK,GAAGC,EAAe,CAAC,+BACxB,OAAQ,IAAM,IACZ,aAAU,KACV,WAAQ,uBAAuB,CACjC,EACF,CAEJ,CAEe,SAARC,GAAyC,CAC9C,GAAM,CAAE,UAAAC,EAAW,SAAAC,EAAU,MAAAN,EAAO,QAAAO,CAAQ,EAAIC,GAAY,EAC5D,OAAIR,MACF,aAAU,CAAE,MAAO,QAAM,MAAM,QAAS,MAAO,QAAS,QAASA,CAAM,CAAC,KAGxE,QAAC,QACC,UAAWK,EACX,qBAAsBA,IAAc,GAAO,4BAA8B,kBAEzE,oBAAC,OAAK,QAAL,CAAa,MAAM,WAAW,SAAU,GAAGC,GAAU,MAAM,GACzD,SAAAA,GAAU,IAAKnB,MACd,OAACU,EAAA,CAAgC,QAASV,GAApBA,EAAE,OAAqB,CAC9C,EACH,EACCa,MACC,OAAC,OAAK,UAAL,CACC,MAAM,gDACN,YAAY,0EACZ,KAAK,eACL,WACE,QAAC,eACC,oBAAC,UACC,MAAM,SACN,KAAM,OAAK,gBACX,SAAU,CAAE,UAAW,CAAC,KAAK,EAAG,IAAK,GAAI,EACzC,SAAUO,EACZ,KACA,OAACL,EAAA,EAA8B,GACjC,EAEJ,GAEJ,CAEJ,CAEA,eAAeN,EAAiBa,EAA0D,CACxF,IAAMC,EAAO,MAAU,WAASD,EAAU,OAAO,EAC3CE,EAAS,KAAK,MAAMD,CAAI,EAC9B,aAAU,KAAGD,CAAQ,EACdE,CACT,CAEA,SAASH,IAKP,CACA,GAAM,CAACH,EAAWO,CAAY,KAAI,YAAS,EAAI,EACzC,CAACN,EAAUO,CAAW,KAAI,YAA4B,EACtD,CAACb,EAAOc,CAAQ,KAAI,YAAiB,EACrC,CAACC,EAAMC,CAAO,KAAI,YAAS,IAAI,IAAM,EAErCT,EAAU,IAAM,CACpBS,EAAQ,IAAI,IAAM,CACpB,EAEA,sBAAU,IAAM,CACd,IAAIC,EAAa,GACjB,eAAeC,GAAgB,CAC7B,GAAI,CAAAD,EAGJ,CAAAL,EAAa,EAAI,EACjBE,EAAS,MAAS,EAClB,GAAI,CACF,IAAMK,EAAO,MAAM7B,EAAqB,EACnC2B,GACHJ,EAAYM,CAAI,CAEpB,OAASnB,EAAO,CACTiB,GACHH,EAASb,EAAgBD,CAAK,CAAC,CAEnC,QAAE,CACKiB,GACHL,EAAa,EAAK,CAEtB,EACF,CACA,OAAAM,EAAc,EACP,IAAM,CACXD,EAAa,EACf,CACF,EAAG,CAACF,CAAI,CAAC,EAEF,CAAE,SAAAT,EAAU,UAAAD,EAAW,MAAAL,EAAO,QAAAO,CAAQ,CAC/C",
  "names": ["commandpalette_exports", "__export", "CommandPaletteCommand", "__toCommonJS", "import_api", "afs", "os", "import_path", "import_react", "import_api", "import_api", "fs", "getErrorMessage", "error", "fileExists", "filename", "fmt", "sleep", "ms", "resolve", "waitForFileExists", "filename", "timeoutMs", "start", "fileExists", "raycastForVSCodeURI", "uri", "getBuildScheme", "openURIinVSCode", "isWin", "isMac", "import_api", "cacheFunc", "fn", "options", "val", "lastRun", "wrapper", "args", "cachedGetApplications", "cacheFunc", "import_api", "preferences", "build", "layout", "keepSectionOrder", "closeOtherWindows", "terminalApp", "showGitBranch", "gitBranchColor", "getBuildNamePreference", "buildSchemes", "getBuildScheme", "scheme", "import_jsx_runtime", "transitFolder", "build", "getBuildNamePreference", "ts", "path", "isWin", "CreateCommandQuickLinkAction", "props", "c", "title", "raycastForVSCodeURI", "getCommandFromVSCode", "tsFolder", "requestFilename", "responseFilename", "fileExists", "waitForFileExists", "readCommandsFile", "CommandListItem", "handle", "openURIinVSCode", "error", "getErrorMessage", "InstallRaycastForVSCodeAction", "getBuildScheme", "CommandPaletteCommand", "isLoading", "commands", "refresh", "useCommands", "filename", "data", "result", "setIsLoading", "setCommands", "setError", "date", "setDate", "didUnmount", "fetchCommands", "cmds"]
}
