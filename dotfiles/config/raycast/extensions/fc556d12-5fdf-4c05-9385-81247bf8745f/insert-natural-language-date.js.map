{
  "version": 3,
  "sources": ["../node_modules/dayjs/plugin/quarterOfYear.js", "../node_modules/dayjs/dayjs.min.js", "../src/insert-natural-language-date.tsx", "../node_modules/chrono-node/src/results.ts", "../node_modules/chrono-node/src/types.ts", "../node_modules/chrono-node/src/utils/dates.ts", "../node_modules/chrono-node/src/timezone.ts", "../node_modules/chrono-node/src/calculation/duration.ts", "../node_modules/chrono-node/src/utils/pattern.ts", "../node_modules/chrono-node/src/calculation/years.ts", "../node_modules/chrono-node/src/locales/en/constants.ts", "../node_modules/chrono-node/src/common/parsers/AbstractParserWithWordBoundary.ts", "../node_modules/chrono-node/src/locales/en/parsers/ENTimeUnitWithinFormatParser.ts", "../node_modules/chrono-node/src/locales/en/parsers/ENMonthNameLittleEndianParser.ts", "../node_modules/chrono-node/src/locales/en/parsers/ENMonthNameMiddleEndianParser.ts", "../node_modules/chrono-node/src/locales/en/parsers/ENMonthNameParser.ts", "../node_modules/chrono-node/src/locales/en/parsers/ENYearMonthDayParser.ts", "../node_modules/chrono-node/src/locales/en/parsers/ENSlashMonthFormatParser.ts", "../node_modules/chrono-node/src/common/parsers/AbstractTimeExpressionParser.ts", "../node_modules/chrono-node/src/locales/en/parsers/ENTimeExpressionParser.ts", "../node_modules/chrono-node/src/locales/en/parsers/ENTimeUnitAgoFormatParser.ts", "../node_modules/chrono-node/src/locales/en/parsers/ENTimeUnitLaterFormatParser.ts", "../node_modules/chrono-node/src/common/abstractRefiners.ts", "../node_modules/chrono-node/src/common/refiners/AbstractMergeDateRangeRefiner.ts", "../node_modules/chrono-node/src/locales/en/refiners/ENMergeDateRangeRefiner.ts", "../node_modules/chrono-node/src/utils/dayjs.ts", "../node_modules/chrono-node/src/calculation/mergingCalculation.ts", "../node_modules/chrono-node/src/common/refiners/AbstractMergeDateTimeRefiner.ts", "../node_modules/chrono-node/src/locales/en/refiners/ENMergeDateTimeRefiner.ts", "../node_modules/chrono-node/src/common/refiners/ExtractTimezoneAbbrRefiner.ts", "../node_modules/chrono-node/src/common/refiners/ExtractTimezoneOffsetRefiner.ts", "../node_modules/chrono-node/src/common/refiners/OverlapRemovalRefiner.ts", "../node_modules/chrono-node/src/common/refiners/ForwardDateRefiner.ts", "../node_modules/chrono-node/src/common/refiners/UnlikelyFormatFilter.ts", "../node_modules/chrono-node/src/common/parsers/ISOFormatParser.ts", "../node_modules/chrono-node/src/common/refiners/MergeWeekdayComponentRefiner.ts", "../node_modules/chrono-node/src/configurations.ts", "../node_modules/chrono-node/src/locales/en/parsers/ENCasualDateParser.ts", "../node_modules/chrono-node/src/common/casualReferences.ts", "../node_modules/chrono-node/src/locales/en/parsers/ENCasualTimeParser.ts", "../node_modules/chrono-node/src/utils/timeunits.ts", "../node_modules/chrono-node/src/calculation/weekdays.ts", "../node_modules/chrono-node/src/locales/en/parsers/ENWeekdayParser.ts", "../node_modules/chrono-node/src/locales/en/parsers/ENRelativeDateFormatParser.ts", "../node_modules/chrono-node/src/common/parsers/SlashDateFormatParser.ts", "../node_modules/chrono-node/src/locales/en/parsers/ENTimeUnitCasualRelativeFormatParser.ts", "../node_modules/chrono-node/src/locales/en/refiners/ENMergeRelativeAfterDateRefiner.ts", "../node_modules/chrono-node/src/locales/en/refiners/ENMergeRelativeFollowByDateRefiner.ts", "../node_modules/chrono-node/src/locales/en/refiners/ENExtractYearSuffixRefiner.ts", "../node_modules/chrono-node/src/locales/en/refiners/ENUnlikelyFormatFilter.ts", "../node_modules/chrono-node/src/locales/en/configuration.ts", "../node_modules/chrono-node/src/chrono.ts", "../node_modules/chrono-node/src/locales/en/index.ts", "../node_modules/chrono-node/src/index.ts"],
  "sourcesContent": ["!function(t,n){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=n():\"function\"==typeof define&&define.amd?define(n):(t=\"undefined\"!=typeof globalThis?globalThis:t||self).dayjs_plugin_quarterOfYear=n()}(this,(function(){\"use strict\";var t=\"month\",n=\"quarter\";return function(e,i){var r=i.prototype;r.quarter=function(t){return this.$utils().u(t)?Math.ceil((this.month()+1)/3):this.month(this.month()%3+3*(t-1))};var s=r.add;r.add=function(e,i){return e=Number(e),this.$utils().p(i)===n?this.add(3*e,t):s.bind(this)(e,i)};var u=r.startOf;r.startOf=function(e,i){var r=this.$utils(),s=!!r.u(i)||i;if(r.p(e)===n){var o=this.quarter()-1;return s?this.month(3*o).startOf(t).startOf(\"day\"):this.month(3*o+2).endOf(t).endOf(\"day\")}return u.bind(this)(e,i)}}}));", "!function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(e):(t=\"undefined\"!=typeof globalThis?globalThis:t||self).dayjs=e()}(this,(function(){\"use strict\";var t=1e3,e=6e4,n=36e5,r=\"millisecond\",i=\"second\",s=\"minute\",u=\"hour\",a=\"day\",o=\"week\",c=\"month\",f=\"quarter\",h=\"year\",d=\"date\",l=\"Invalid Date\",$=/^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/,y=/\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:\"en\",weekdays:\"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday\".split(\"_\"),months:\"January_February_March_April_May_June_July_August_September_October_November_December\".split(\"_\"),ordinal:function(t){var e=[\"th\",\"st\",\"nd\",\"rd\"],n=t%100;return\"[\"+t+(e[(n-20)%10]||e[n]||e[0])+\"]\"}},m=function(t,e,n){var r=String(t);return!r||r.length>=e?t:\"\"+Array(e+1-r.length).join(n)+t},v={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return(e<=0?\"+\":\"-\")+m(r,2,\"0\")+\":\"+m(i,2,\"0\")},m:function t(e,n){if(e.date()<n.date())return-t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,c),s=n-i<0,u=e.clone().add(r+(s?-1:1),c);return+(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return{M:c,y:h,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:f}[t]||String(t||\"\").toLowerCase().replace(/s$/,\"\")},u:function(t){return void 0===t}},g=\"en\",D={};D[g]=M;var p=\"$isDayjsObject\",S=function(t){return t instanceof _||!(!t||!t[p])},w=function t(e,n,r){var i;if(!e)return g;if(\"string\"==typeof e){var s=e.toLowerCase();D[s]&&(i=s),n&&(D[s]=n,i=s);var u=e.split(\"-\");if(!i&&u.length>1)return t(u[0])}else{var a=e.name;D[a]=e,i=a}return!r&&i&&(g=i),i||!r&&g},O=function(t,e){if(S(t))return t.clone();var n=\"object\"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},b=v;b.l=w,b.i=S,b.w=function(t,e){return O(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=w(t.locale,null,!0),this.parse(t),this.$x=this.$x||t.x||{},this[p]=!0}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(b.u(e))return new Date;if(e instanceof Date)return new Date(e);if(\"string\"==typeof e&&!/Z$/i.test(e)){var r=e.match($);if(r){var i=r[2]-1||0,s=(r[7]||\"0\").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.init()},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds()},m.$utils=function(){return b},m.isValid=function(){return!(this.$d.toString()===l)},m.isSame=function(t,e){var n=O(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return O(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<O(t)},m.$g=function(t,e,n){return b.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!b.u(e)||e,f=b.p(t),l=function(t,e){var i=b.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},$=function(t,e){return b.w(n.toDate()[t].apply(n.toDate(\"s\"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,v=\"set\"+(this.$u?\"UTC\":\"\");switch(f){case h:return r?l(1,0):l(31,11);case c:return r?l(1,M):l(0,M+1);case o:var g=this.$locale().weekStart||0,D=(y<g?y+7:y)-g;return l(r?m-D:m+(6-D),M);case a:case d:return $(v+\"Hours\",0);case u:return $(v+\"Minutes\",1);case s:return $(v+\"Seconds\",2);case i:return $(v+\"Milliseconds\",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=b.p(t),f=\"set\"+(this.$u?\"UTC\":\"\"),l=(n={},n[a]=f+\"Date\",n[d]=f+\"Date\",n[c]=f+\"Month\",n[h]=f+\"FullYear\",n[u]=f+\"Hours\",n[s]=f+\"Minutes\",n[i]=f+\"Seconds\",n[r]=f+\"Milliseconds\",n)[o],$=o===a?this.$D+(e-this.$W):e;if(o===c||o===h){var y=this.clone().set(d,1);y.$d[l]($),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d}else l&&this.$d[l]($);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[b.p(t)]()},m.add=function(r,f){var d,l=this;r=Number(r);var $=b.p(f),y=function(t){var e=O(l);return b.w(e.date(e.date()+Math.round(t*r)),l)};if($===c)return this.set(c,this.$M+r);if($===h)return this.set(h,this.$y+r);if($===a)return y(1);if($===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[$]||1,m=this.$d.getTime()+r*M;return b.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||l;var r=t||\"YYYY-MM-DDTHH:mm:ssZ\",i=b.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,c=n.months,f=n.meridiem,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].slice(0,s)},d=function(t){return b.s(s%12||12,t,\"0\")},$=f||function(t,e,n){var r=t<12?\"AM\":\"PM\";return n?r.toLowerCase():r};return r.replace(y,(function(t,r){return r||function(t){switch(t){case\"YY\":return String(e.$y).slice(-2);case\"YYYY\":return b.s(e.$y,4,\"0\");case\"M\":return a+1;case\"MM\":return b.s(a+1,2,\"0\");case\"MMM\":return h(n.monthsShort,a,c,3);case\"MMMM\":return h(c,a);case\"D\":return e.$D;case\"DD\":return b.s(e.$D,2,\"0\");case\"d\":return String(e.$W);case\"dd\":return h(n.weekdaysMin,e.$W,o,2);case\"ddd\":return h(n.weekdaysShort,e.$W,o,3);case\"dddd\":return o[e.$W];case\"H\":return String(s);case\"HH\":return b.s(s,2,\"0\");case\"h\":return d(1);case\"hh\":return d(2);case\"a\":return $(s,u,!0);case\"A\":return $(s,u,!1);case\"m\":return String(u);case\"mm\":return b.s(u,2,\"0\");case\"s\":return String(e.$s);case\"ss\":return b.s(e.$s,2,\"0\");case\"SSS\":return b.s(e.$ms,3,\"0\");case\"Z\":return i}return null}(t)||i.replace(\":\",\"\")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,l){var $,y=this,M=b.p(d),m=O(r),v=(m.utcOffset()-this.utcOffset())*e,g=this-m,D=function(){return b.m(y,m)};switch(M){case h:$=D()/12;break;case c:$=D();break;case f:$=D()/3;break;case o:$=(g-v)/6048e5;break;case a:$=(g-v)/864e5;break;case u:$=g/n;break;case s:$=g/e;break;case i:$=g/t;break;default:$=g}return l?$:b.a($)},m.daysInMonth=function(){return this.endOf(c).$D},m.$locale=function(){return D[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=w(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return b.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),k=_.prototype;return O.prototype=k,[[\"$ms\",r],[\"$s\",i],[\"$m\",s],[\"$H\",u],[\"$W\",a],[\"$M\",c],[\"$y\",h],[\"$D\",d]].forEach((function(t){k[t[1]]=function(e){return this.$g(e,t[0],t[1])}})),O.extend=function(t,e){return t.$i||(t(e,_,O),t.$i=!0),O},O.locale=w,O.isDayjs=S,O.unix=function(t){return O(1e3*t)},O.en=D[g],O.Ls=D,O.p={},O}));", "import { Clipboard, getPreferenceValues, LaunchProps, showToast, Toast } from \"@raycast/api\";\nimport { parseDate } from \"chrono-node\";\nimport dayjs from \"dayjs\";\n\nconst isValidFormat = (format: string): boolean => {\n  // https://day.js.org/docs/en/display/format\n  const validTokens = [\n    \"YYYY\",\n    \"YY\",\n    \"MMMM\",\n    \"MMM\",\n    \"MM\",\n    \"M\",\n    \"DD\",\n    \"D\",\n    \"dddd\",\n    \"ddd\",\n    \"dd\",\n    \"d\",\n    \"HH\",\n    \"H\",\n    \"hh\",\n    \"h\",\n    \"mm\",\n    \"m\",\n    \"ss\",\n    \"s\",\n    \"SSS\",\n    \"ZZ\",\n    \"Z\",\n    \"A\",\n    \"a\",\n  ];\n  const stripped = format.replace(/[-/.,: ]/g, \"\");\n  const remaining = validTokens.reduce((str, token) => str.replaceAll(token, \"\"), stripped);\n  return remaining.length === 0;\n};\n\nconst InsertNaturalLanguageDate = async (\n  props: LaunchProps<{\n    arguments: Arguments.InsertNaturalLanguageDate;\n  }>\n): Promise<void> => {\n  const prompt = props.arguments.prompt || \"today\";\n  const parsed = parseDate(prompt);\n  if (!parsed) {\n    await showToast({\n      style: Toast.Style.Failure,\n      title: `Failed to parse date prompt: ${prompt}`,\n    });\n    return;\n  }\n  const format =\n    props.arguments.format || getPreferenceValues<Preferences.InsertNaturalLanguageDate>().naturalLanguageDateFormat;\n  if (!isValidFormat(format)) {\n    await showToast({\n      style: Toast.Style.Failure,\n      title: `Invalid date format: ${format}`,\n    });\n    return;\n  }\n  const formatted = dayjs(parsed).format(format);\n  await Clipboard.paste(formatted);\n};\n\nexport default InsertNaturalLanguageDate;\n", "import { Component, ParsedComponents, ParsedResult, ParsingReference } from \"./types\";\n\nimport quarterOfYear from \"dayjs/plugin/quarterOfYear\";\nimport dayjs, { QUnitType } from \"dayjs\";\nimport { assignSimilarDate, assignSimilarTime, implySimilarTime } from \"./utils/dates\";\nimport { toTimezoneOffset } from \"./timezone\";\nimport { addDuration, Duration } from \"./calculation/duration\";\ndayjs.extend(quarterOfYear);\n\nexport class ReferenceWithTimezone {\n    readonly instant: Date;\n    readonly timezoneOffset?: number | null;\n\n    constructor(input?: ParsingReference | Date) {\n        input = input ?? new Date();\n        if (input instanceof Date) {\n            this.instant = input;\n            this.timezoneOffset = null;\n        } else {\n            this.instant = input.instant ?? new Date();\n            this.timezoneOffset = toTimezoneOffset(input.timezone, this.instant);\n        }\n    }\n\n    /**\n     * Returns a JS date (system timezone) with the { year, month, day, hour, minute, second } equal to the reference.\n     * The output's instant is NOT the reference's instant when the reference's and system's timezone are different.\n     */\n    getDateWithAdjustedTimezone() {\n        const date = new Date(this.instant);\n        if (this.timezoneOffset !== null) {\n            date.setMinutes(date.getMinutes() - this.getSystemTimezoneAdjustmentMinute(this.instant));\n        }\n        return date;\n    }\n\n    /**\n     * Returns the number minutes difference between the JS date's timezone and the reference timezone.\n     * @param date\n     * @param overrideTimezoneOffset\n     */\n    getSystemTimezoneAdjustmentMinute(date?: Date, overrideTimezoneOffset?: number): number {\n        if (!date || date.getTime() < 0) {\n            // Javascript date timezone calculation got effect when the time epoch < 0\n            // e.g. new Date('Tue Feb 02 1300 00:00:00 GMT+0900 (JST)') => Tue Feb 02 1300 00:18:59 GMT+0918 (JST)\n            date = new Date();\n        }\n\n        const currentTimezoneOffset = -date.getTimezoneOffset();\n        const targetTimezoneOffset = overrideTimezoneOffset ?? this.timezoneOffset ?? currentTimezoneOffset;\n        return currentTimezoneOffset - targetTimezoneOffset;\n    }\n\n    getTimezoneOffset(): number {\n        return this.timezoneOffset ?? -this.instant.getTimezoneOffset();\n    }\n}\n\nexport class ParsingComponents implements ParsedComponents {\n    private knownValues: { [c in Component]?: number };\n    private impliedValues: { [c in Component]?: number };\n    private reference: ReferenceWithTimezone;\n    private _tags = new Set<string>();\n\n    constructor(reference: ReferenceWithTimezone, knownComponents?: { [c in Component]?: number }) {\n        this.reference = reference;\n        this.knownValues = {};\n        this.impliedValues = {};\n        if (knownComponents) {\n            for (const key in knownComponents) {\n                this.knownValues[key as Component] = knownComponents[key as Component];\n            }\n        }\n\n        const refDayJs = reference.getDateWithAdjustedTimezone();\n        this.imply(\"day\", refDayJs.getDate());\n        this.imply(\"month\", refDayJs.getMonth() + 1);\n        this.imply(\"year\", refDayJs.getFullYear());\n        this.imply(\"hour\", 12);\n        this.imply(\"minute\", 0);\n        this.imply(\"second\", 0);\n        this.imply(\"millisecond\", 0);\n    }\n\n    get(component: Component): number | null {\n        if (component in this.knownValues) {\n            return this.knownValues[component];\n        }\n\n        if (component in this.impliedValues) {\n            return this.impliedValues[component];\n        }\n\n        return null;\n    }\n\n    isCertain(component: Component): boolean {\n        return component in this.knownValues;\n    }\n\n    getCertainComponents(): Array<Component> {\n        return Object.keys(this.knownValues) as Array<Component>;\n    }\n\n    imply(component: Component, value: number): ParsingComponents {\n        if (component in this.knownValues) {\n            return this;\n        }\n        this.impliedValues[component] = value;\n        return this;\n    }\n\n    assign(component: Component, value: number): ParsingComponents {\n        this.knownValues[component] = value;\n        delete this.impliedValues[component];\n        return this;\n    }\n\n    delete(component: Component) {\n        delete this.knownValues[component];\n        delete this.impliedValues[component];\n    }\n\n    clone(): ParsingComponents {\n        const component = new ParsingComponents(this.reference);\n        component.knownValues = {};\n        component.impliedValues = {};\n\n        for (const key in this.knownValues) {\n            component.knownValues[key as Component] = this.knownValues[key as Component];\n        }\n\n        for (const key in this.impliedValues) {\n            component.impliedValues[key as Component] = this.impliedValues[key as Component];\n        }\n\n        return component;\n    }\n\n    isOnlyDate(): boolean {\n        return !this.isCertain(\"hour\") && !this.isCertain(\"minute\") && !this.isCertain(\"second\");\n    }\n\n    isOnlyTime(): boolean {\n        return (\n            !this.isCertain(\"weekday\") && !this.isCertain(\"day\") && !this.isCertain(\"month\") && !this.isCertain(\"year\")\n        );\n    }\n\n    isOnlyWeekdayComponent(): boolean {\n        return this.isCertain(\"weekday\") && !this.isCertain(\"day\") && !this.isCertain(\"month\");\n    }\n\n    isDateWithUnknownYear(): boolean {\n        return this.isCertain(\"month\") && !this.isCertain(\"year\");\n    }\n\n    isValidDate(): boolean {\n        const date = this.dateWithoutTimezoneAdjustment();\n\n        if (date.getFullYear() !== this.get(\"year\")) return false;\n        if (date.getMonth() !== this.get(\"month\") - 1) return false;\n        if (date.getDate() !== this.get(\"day\")) return false;\n        if (this.get(\"hour\") != null && date.getHours() != this.get(\"hour\")) return false;\n        if (this.get(\"minute\") != null && date.getMinutes() != this.get(\"minute\")) return false;\n\n        return true;\n    }\n\n    toString() {\n        return `[ParsingComponents {\n            tags: ${JSON.stringify(Array.from(this._tags).sort())}, \n            knownValues: ${JSON.stringify(this.knownValues)}, \n            impliedValues: ${JSON.stringify(this.impliedValues)}}, \n            reference: ${JSON.stringify(this.reference)}]`;\n    }\n\n    dayjs() {\n        return dayjs(this.dateWithoutTimezoneAdjustment());\n    }\n\n    date(): Date {\n        const date = this.dateWithoutTimezoneAdjustment();\n        const timezoneAdjustment = this.reference.getSystemTimezoneAdjustmentMinute(date, this.get(\"timezoneOffset\"));\n        return new Date(date.getTime() + timezoneAdjustment * 60000);\n    }\n\n    addTag(tag: string): ParsingComponents {\n        this._tags.add(tag);\n        return this;\n    }\n\n    addTags(tags: string[] | Set<string>): ParsingComponents {\n        for (const tag of tags) {\n            this._tags.add(tag);\n        }\n        return this;\n    }\n\n    tags(): Set<string> {\n        return new Set(this._tags);\n    }\n\n    private dateWithoutTimezoneAdjustment() {\n        const date = new Date(\n            this.get(\"year\"),\n            this.get(\"month\") - 1,\n            this.get(\"day\"),\n            this.get(\"hour\"),\n            this.get(\"minute\"),\n            this.get(\"second\"),\n            this.get(\"millisecond\")\n        );\n\n        date.setFullYear(this.get(\"year\"));\n        return date;\n    }\n\n    static createRelativeFromReference(reference: ReferenceWithTimezone, duration: Duration): ParsingComponents {\n        let date = addDuration(reference.getDateWithAdjustedTimezone(), duration);\n\n        const components = new ParsingComponents(reference);\n        components.addTag(\"result/relativeDate\");\n        if (duration[\"hour\"] || duration[\"minute\"] || duration[\"second\"]) {\n            components.addTag(\"result/relativeDateAndTime\");\n            assignSimilarTime(components, date);\n            assignSimilarDate(components, date);\n            components.assign(\"timezoneOffset\", reference.getTimezoneOffset());\n        } else {\n            implySimilarTime(components, date);\n            components.imply(\"timezoneOffset\", reference.getTimezoneOffset());\n\n            if (duration[\"day\"]) {\n                components.assign(\"day\", date.getDate());\n                components.assign(\"month\", date.getMonth() + 1);\n                components.assign(\"year\", date.getFullYear());\n                components.assign(\"weekday\", date.getDay());\n            } else if (duration[\"week\"]) {\n                components.assign(\"day\", date.getDate());\n                components.assign(\"month\", date.getMonth() + 1);\n                components.assign(\"year\", date.getFullYear());\n                components.imply(\"weekday\", date.getDay());\n            } else {\n                components.imply(\"day\", date.getDate());\n                if (duration[\"month\"]) {\n                    components.assign(\"month\", date.getMonth() + 1);\n                    components.assign(\"year\", date.getFullYear());\n                } else {\n                    components.imply(\"month\", date.getMonth() + 1);\n                    if (duration[\"year\"]) {\n                        components.assign(\"year\", date.getFullYear());\n                    } else {\n                        components.imply(\"year\", date.getFullYear());\n                    }\n                }\n            }\n        }\n\n        return components;\n    }\n}\n\nexport class ParsingResult implements ParsedResult {\n    refDate: Date;\n    index: number;\n    text: string;\n\n    reference: ReferenceWithTimezone;\n\n    start: ParsingComponents;\n    end?: ParsingComponents;\n\n    constructor(\n        reference: ReferenceWithTimezone,\n        index: number,\n        text: string,\n        start?: ParsingComponents,\n        end?: ParsingComponents\n    ) {\n        this.reference = reference;\n        this.refDate = reference.instant;\n        this.index = index;\n        this.text = text;\n        this.start = start || new ParsingComponents(reference);\n        this.end = end;\n    }\n\n    clone() {\n        const result = new ParsingResult(this.reference, this.index, this.text);\n        result.start = this.start ? this.start.clone() : null;\n        result.end = this.end ? this.end.clone() : null;\n        return result;\n    }\n\n    date(): Date {\n        return this.start.date();\n    }\n\n    addTag(tag: string): ParsingResult {\n        this.start.addTag(tag);\n        if (this.end) {\n            this.end.addTag(tag);\n        }\n        return this;\n    }\n\n    addTags(tags: string[] | Set<string>): ParsingResult {\n        this.start.addTags(tags);\n        if (this.end) {\n            this.end.addTags(tags);\n        }\n        return this;\n    }\n\n    tags(): Set<string> {\n        const combinedTags: Set<string> = new Set(this.start.tags());\n        if (this.end) {\n            for (const tag of this.end.tags()) {\n                combinedTags.add(tag);\n            }\n        }\n        return combinedTags;\n    }\n\n    toString() {\n        const tags = Array.from(this.tags()).sort();\n        return `[ParsingResult {index: ${this.index}, text: '${this.text}', tags: ${JSON.stringify(tags)} ...}]`;\n    }\n}\n", "import { DebugConsume, DebugHandler } from \"./debugging\";\n\nexport interface ParsingOption {\n    /**\n     * To parse only forward dates (the results should be after the reference date).\n     * This effects date/time implication (e.g. weekday or time mentioning)\n     */\n    forwardDate?: boolean;\n\n    /**\n     * Additional timezone keywords for the parsers to recognize.\n     * Any value provided will override the default handling of that value.\n     */\n    timezones?: TimezoneAbbrMap;\n\n    /**\n     * Internal debug event handler.\n     * @internal\n     */\n    debug?: DebugHandler | DebugConsume;\n}\n\n/**\n * Some timezone abbreviations are ambiguous in that they refer to different offsets\n * depending on the time of year \u2014 daylight savings time (DST), or non-DST. This interface\n * allows defining such timezones\n */\nexport interface AmbiguousTimezoneMap {\n    timezoneOffsetDuringDst: number;\n    timezoneOffsetNonDst: number;\n    /**\n     * Return the start date of DST for the given year.\n     * timezone.ts contains helper methods for common such rules.\n     */\n    dstStart: (year: number) => Date;\n    /**\n     * Return the end date of DST for the given year.\n     * timezone.ts contains helper methods for common such rules.\n     */\n    dstEnd: (year: number) => Date;\n}\n\n/**\n * A map describing how timezone abbreviations should map to time offsets.\n * Supports both unambigous mappings abbreviation => offset,\n * and ambiguous mappings, where the offset will depend on whether the\n * time in question is during daylight savings time or not.\n */\nexport type TimezoneAbbrMap = { [key: string]: number | AmbiguousTimezoneMap };\n\nexport interface ParsingReference {\n    /**\n     * Reference date. The instant (JavaScript Date object) when the input is written or mention.\n     * This effect date/time implication (e.g. weekday or time mentioning).\n     * (default = now)\n     */\n    instant?: Date;\n\n    /**\n     * Reference timezone. The timezone where the input is written or mention.\n     * Date/time implication will account the difference between input timezone and the current system timezone.\n     * (default = current timezone)\n     */\n    timezone?: string | number;\n}\n\n/**\n * Parsed result or final output.\n * Each result object represents a date/time (or date/time-range) mentioning in the input.\n */\nexport interface ParsedResult {\n    readonly refDate: Date;\n    readonly index: number;\n    readonly text: string;\n\n    readonly start: ParsedComponents;\n    readonly end?: ParsedComponents;\n\n    /**\n     * @return a javascript date object created from the `result.start`.\n     */\n    date(): Date;\n\n    /**\n     * @return debugging tags combined of the `result.start` and `result.end`.\n     */\n    tags(): Set<string>;\n}\n\n/**\n * A collection of parsed date/time components (e.g. day, hour, minute, ..., etc).\n *\n * Each parsed component has three different levels of certainty.\n * - *Certain* (or *Known*): The component is directly mentioned and parsed.\n * - *Implied*: The component is not directly mentioned, but implied by other parsed information.\n * - *Unknown*: Completely no mention of the component.\n */\nexport interface ParsedComponents {\n    /**\n     * Check the component certainly if the component is *Certain* (or *Known*)\n     */\n    isCertain(component: Component): boolean;\n\n    /**\n     * Get the component value for either *Certain* or *Implied* value.\n     */\n    get(component: Component): number | null;\n\n    /**\n     * @return a javascript date object.\n     */\n    date(): Date;\n\n    /**\n     * @return debugging tags of the parsed component.\n     */\n    tags(): Set<string>;\n}\n\nexport type Component =\n    | \"year\"\n    | \"month\"\n    | \"day\"\n    | \"weekday\"\n    | \"hour\"\n    | \"minute\"\n    | \"second\"\n    | \"millisecond\"\n    | \"meridiem\"\n    | \"timezoneOffset\";\n\nexport type Timeunit = \"year\" | \"month\" | \"week\" | \"day\" | \"hour\" | \"minute\" | \"second\" | \"millisecond\";\n\nexport enum Meridiem {\n    AM = 0,\n    PM = 1,\n}\n\nexport enum Weekday {\n    SUNDAY = 0,\n    MONDAY = 1,\n    TUESDAY = 2,\n    WEDNESDAY = 3,\n    THURSDAY = 4,\n    FRIDAY = 5,\n    SATURDAY = 6,\n}\n\nexport enum Month {\n    JANUARY = 1,\n    FEBRUARY = 2,\n    MARCH = 3,\n    APRIL = 4,\n    MAY = 5,\n    JUNE = 6,\n    JULY = 7,\n    AUGUST = 8,\n    SEPTEMBER = 9,\n    OCTOBER = 10,\n    NOVEMBER = 11,\n    DECEMBER = 12,\n}\n", "import { ParsingComponents } from \"../results\";\nimport { Meridiem } from \"../types\";\n\n/**\n * Assign (force update) the parsing component to the same day as the `target`.\n * @param component the component to be updated.\n * @param target the target date with timezone adjusted.\n */\nexport function assignSimilarDate(component: ParsingComponents, target: Date) {\n    component.assign(\"day\", target.getDate());\n    component.assign(\"month\", target.getMonth() + 1);\n    component.assign(\"year\", target.getFullYear());\n}\n\n/**\n * Assign (force update) the parsing component to the same time as the `target`.\n * @param component the component to be updated.\n * @param target the target date with timezone adjusted.\n */\nexport function assignSimilarTime(component: ParsingComponents, target: Date) {\n    component.assign(\"hour\", target.getHours());\n    component.assign(\"minute\", target.getMinutes());\n    component.assign(\"second\", target.getSeconds());\n    component.assign(\"millisecond\", target.getMilliseconds());\n    component.assign(\"meridiem\", target.getHours() < 12 ? Meridiem.AM : Meridiem.PM);\n}\n\n/**\n * Imply (weakly update) the parsing component to the same day as the `target`.\n * @param component the component to be updated.\n * @param target the target date with timezone adjusted.\n */\nexport function implySimilarDate(component: ParsingComponents, target: Date) {\n    component.imply(\"day\", target.getDate());\n    component.imply(\"month\", target.getMonth() + 1);\n    component.imply(\"year\", target.getFullYear());\n}\n\n/**\n * Imply (weakly update) the parsing component to the same time as the `target`.\n * @param component the component to be updated.\n * @param target the target date with timezone adjusted.\n */\nexport function implySimilarTime(component: ParsingComponents, target: Date) {\n    component.imply(\"hour\", target.getHours());\n    component.imply(\"minute\", target.getMinutes());\n    component.imply(\"second\", target.getSeconds());\n    component.imply(\"millisecond\", target.getMilliseconds());\n    component.imply(\"meridiem\", target.getHours() < 12 ? Meridiem.AM : Meridiem.PM);\n}\n", "import dayjs from \"dayjs\";\nimport { TimezoneAbbrMap, Weekday, Month } from \"./types\";\n\nexport const TIMEZONE_ABBR_MAP: TimezoneAbbrMap = {\n    ACDT: 630,\n    ACST: 570,\n    ADT: -180,\n    AEDT: 660,\n    AEST: 600,\n    AFT: 270,\n    AKDT: -480,\n    AKST: -540,\n    ALMT: 360,\n    AMST: -180,\n    AMT: -240,\n    ANAST: 720,\n    ANAT: 720,\n    AQTT: 300,\n    ART: -180,\n    AST: -240,\n    AWDT: 540,\n    AWST: 480,\n    AZOST: 0,\n    AZOT: -60,\n    AZST: 300,\n    AZT: 240,\n    BNT: 480,\n    BOT: -240,\n    BRST: -120,\n    BRT: -180,\n    BST: 60,\n    BTT: 360,\n    CAST: 480,\n    CAT: 120,\n    CCT: 390,\n    CDT: -300,\n    CEST: 120,\n    // Note: Many sources define CET as a constant UTC+1. In common usage, however,\n    // CET usually refers to the time observed in most of Europe, be it standard time or daylight saving time.\n    CET: {\n        timezoneOffsetDuringDst: 2 * 60,\n        timezoneOffsetNonDst: 60,\n        dstStart: (year: number) => getLastWeekdayOfMonth(year, Month.MARCH, Weekday.SUNDAY, 2),\n        dstEnd: (year: number) => getLastWeekdayOfMonth(year, Month.OCTOBER, Weekday.SUNDAY, 3),\n    },\n    CHADT: 825,\n    CHAST: 765,\n    CKT: -600,\n    CLST: -180,\n    CLT: -240,\n    COT: -300,\n    CST: -360,\n    CT: {\n        timezoneOffsetDuringDst: -5 * 60,\n        timezoneOffsetNonDst: -6 * 60,\n        dstStart: (year: number) => getNthWeekdayOfMonth(year, Month.MARCH, Weekday.SUNDAY, 2, 2),\n        dstEnd: (year: number) => getNthWeekdayOfMonth(year, Month.NOVEMBER, Weekday.SUNDAY, 1, 2),\n    },\n    CVT: -60,\n    CXT: 420,\n    ChST: 600,\n    DAVT: 420,\n    EASST: -300,\n    EAST: -360,\n    EAT: 180,\n    ECT: -300,\n    EDT: -240,\n    EEST: 180,\n    EET: 120,\n    EGST: 0,\n    EGT: -60,\n    EST: -300,\n    ET: {\n        timezoneOffsetDuringDst: -4 * 60,\n        timezoneOffsetNonDst: -5 * 60,\n        dstStart: (year: number) => getNthWeekdayOfMonth(year, Month.MARCH, Weekday.SUNDAY, 2, 2),\n        dstEnd: (year: number) => getNthWeekdayOfMonth(year, Month.NOVEMBER, Weekday.SUNDAY, 1, 2),\n    },\n    FJST: 780,\n    FJT: 720,\n    FKST: -180,\n    FKT: -240,\n    FNT: -120,\n    GALT: -360,\n    GAMT: -540,\n    GET: 240,\n    GFT: -180,\n    GILT: 720,\n    GMT: 0,\n    GST: 240,\n    GYT: -240,\n    HAA: -180,\n    HAC: -300,\n    HADT: -540,\n    HAE: -240,\n    HAP: -420,\n    HAR: -360,\n    HAST: -600,\n    HAT: -90,\n    HAY: -480,\n    HKT: 480,\n    HLV: -210,\n    HNA: -240,\n    HNC: -360,\n    HNE: -300,\n    HNP: -480,\n    HNR: -420,\n    HNT: -150,\n    HNY: -540,\n    HOVT: 420,\n    ICT: 420,\n    IDT: 180,\n    IOT: 360,\n    IRDT: 270,\n    IRKST: 540,\n    IRKT: 540,\n    IRST: 210,\n    IST: 330,\n    JST: 540,\n    KGT: 360,\n    KRAST: 480,\n    KRAT: 480,\n    KST: 540,\n    KUYT: 240,\n    LHDT: 660,\n    LHST: 630,\n    LINT: 840,\n    MAGST: 720,\n    MAGT: 720,\n    MART: -510,\n    MAWT: 300,\n    MDT: -360,\n    MESZ: 120,\n    MEZ: 60,\n    MHT: 720,\n    MMT: 390,\n    MSD: 240,\n    MSK: 180,\n    MST: -420,\n    MT: {\n        timezoneOffsetDuringDst: -6 * 60,\n        timezoneOffsetNonDst: -7 * 60,\n        dstStart: (year: number) => getNthWeekdayOfMonth(year, Month.MARCH, Weekday.SUNDAY, 2, 2),\n        dstEnd: (year: number) => getNthWeekdayOfMonth(year, Month.NOVEMBER, Weekday.SUNDAY, 1, 2),\n    },\n    MUT: 240,\n    MVT: 300,\n    MYT: 480,\n    NCT: 660,\n    NDT: -90,\n    NFT: 690,\n    NOVST: 420,\n    NOVT: 360,\n    NPT: 345,\n    NST: -150,\n    NUT: -660,\n    NZDT: 780,\n    NZST: 720,\n    OMSST: 420,\n    OMST: 420,\n    PDT: -420,\n    PET: -300,\n    PETST: 720,\n    PETT: 720,\n    PGT: 600,\n    PHOT: 780,\n    PHT: 480,\n    PKT: 300,\n    PMDT: -120,\n    PMST: -180,\n    PONT: 660,\n    PST: -480,\n    PT: {\n        timezoneOffsetDuringDst: -7 * 60,\n        timezoneOffsetNonDst: -8 * 60,\n        dstStart: (year: number) => getNthWeekdayOfMonth(year, Month.MARCH, Weekday.SUNDAY, 2, 2),\n        dstEnd: (year: number) => getNthWeekdayOfMonth(year, Month.NOVEMBER, Weekday.SUNDAY, 1, 2),\n    },\n    PWT: 540,\n    PYST: -180,\n    PYT: -240,\n    RET: 240,\n    SAMT: 240,\n    SAST: 120,\n    SBT: 660,\n    SCT: 240,\n    SGT: 480,\n    SRT: -180,\n    SST: -660,\n    TAHT: -600,\n    TFT: 300,\n    TJT: 300,\n    TKT: 780,\n    TLT: 540,\n    TMT: 300,\n    TVT: 720,\n    ULAT: 480,\n    UTC: 0,\n    UYST: -120,\n    UYT: -180,\n    UZT: 300,\n    VET: -210,\n    VLAST: 660,\n    VLAT: 660,\n    VUT: 660,\n    WAST: 120,\n    WAT: 60,\n    WEST: 60,\n    WESZ: 60,\n    WET: 0,\n    WEZ: 0,\n    WFT: 720,\n    WGST: -120,\n    WGT: -180,\n    WIB: 420,\n    WIT: 540,\n    WITA: 480,\n    WST: 780,\n    WT: 0,\n    YAKST: 600,\n    YAKT: 600,\n    YAPT: 600,\n    YEKST: 360,\n    YEKT: 360,\n};\n\n/**\n * Get the date which is the nth occurence of a given weekday in a given month and year.\n *\n * @param year The year for which to find the date\n * @param month The month in which the date occurs\n * @param weekday The weekday on which the date occurs\n * @param n The nth occurence of the given weekday on the month to return\n * @param hour The hour of day which should be set on the returned date\n * @return The date which is the nth occurence of a given weekday in a given\n *         month and year, at the given hour of day\n */\nexport function getNthWeekdayOfMonth(year: number, month: Month, weekday: Weekday, n: 1 | 2 | 3 | 4, hour = 0): Date {\n    let dayOfMonth = 0;\n    let i = 0;\n    while (i < n) {\n        dayOfMonth++;\n        const date = new Date(year, month - 1, dayOfMonth);\n        if (date.getDay() === weekday) i++;\n    }\n    return new Date(year, month - 1, dayOfMonth, hour);\n}\n\n/**\n * Get the date which is the last occurence of a given weekday in a given month and year.\n *\n * @param year The year for which to find the date\n * @param month The month in which the date occurs\n * @param weekday The weekday on which the date occurs\n * @param hour The hour of day which should be set on the returned date\n * @return The date which is the last occurence of a given weekday in a given\n *         month and year, at the given hour of day\n */\nexport function getLastWeekdayOfMonth(year: number, month: Month, weekday: Weekday, hour = 0): Date {\n    // Procedure: Find the first weekday of the next month, compare with the given weekday,\n    // and use the difference to determine how many days to subtract from the first of the next month.\n    const oneIndexedWeekday = weekday === 0 ? 7 : weekday;\n    const date = new Date(year, month - 1 + 1, 1, 12);\n    const firstWeekdayNextMonth = date.getDay() === 0 ? 7 : date.getDay();\n    let dayDiff;\n    if (firstWeekdayNextMonth === oneIndexedWeekday) dayDiff = 7;\n    else if (firstWeekdayNextMonth < oneIndexedWeekday) dayDiff = 7 + firstWeekdayNextMonth - oneIndexedWeekday;\n    else dayDiff = firstWeekdayNextMonth - oneIndexedWeekday;\n    date.setDate(date.getDate() - dayDiff);\n    return new Date(year, month - 1, date.getDate(), hour);\n}\n\n/**\n * Finds and returns timezone offset. If timezoneInput is numeric, it is returned. Otherwise, look for timezone offsets\n * in the following order: timezoneOverrides -> {@link TIMEZONE_ABBR_MAP}.\n *\n * @param timezoneInput Uppercase timezone abbreviation or numeric offset in minutes\n * @param date The date to use to determine whether to return DST offsets for ambiguous timezones\n * @param timezoneOverrides Overrides for timezones\n * @return timezone offset in minutes\n */\nexport function toTimezoneOffset(\n    timezoneInput?: string | number,\n    date?: Date,\n    timezoneOverrides: TimezoneAbbrMap = {}\n): number | null {\n    if (timezoneInput == null) {\n        return null;\n    }\n\n    if (typeof timezoneInput === \"number\") {\n        return timezoneInput;\n    }\n\n    const matchedTimezone = timezoneOverrides[timezoneInput] ?? TIMEZONE_ABBR_MAP[timezoneInput];\n    if (matchedTimezone == null) {\n        return null;\n    }\n    // This means that we have matched an unambiguous timezone\n    if (typeof matchedTimezone == \"number\") {\n        return matchedTimezone;\n    }\n\n    // The matched timezone is an ambiguous timezone, where the offset depends on whether the context (refDate)\n    // is during daylight savings or not.\n\n    // Without refDate as context, there's no way to know if DST or non-DST offset should be used. Return null instead.\n    if (date == null) {\n        return null;\n    }\n\n    // Return DST offset if the refDate is during daylight savings\n    if (\n        dayjs(date).isAfter(matchedTimezone.dstStart(date.getFullYear())) &&\n        !dayjs(date).isAfter(matchedTimezone.dstEnd(date.getFullYear()))\n    ) {\n        return matchedTimezone.timezoneOffsetDuringDst;\n    }\n\n    // refDate is not during DST => return non-DST offset\n    return matchedTimezone.timezoneOffsetNonDst;\n}\n", "import { Timeunit } from \"../types\";\n\nexport type TimeunitShorten = \"y\" | \"mo\" | \"M\" | \"w\" | \"d\" | \"h\" | \"m\" | \"s\" | \"ms\";\nexport type TimeunitSpecial = \"quarter\";\n\n/**\n * A type represent a directed time duration as a set of values by timeunits.\n * The positive values mean the time duration into the future.\n */\nexport type Duration = { [c in Timeunit | TimeunitSpecial | TimeunitShorten]?: number };\n\n/**\n * Returns the date after adding the given `duration` to `ref`.\n * @param ref\n * @param duration\n */\nexport function addDuration(ref: Date, duration: Duration): Date {\n    let date = new Date(ref);\n\n    // Replace short timeunit keys with full timeunit keys\n    if (duration[\"y\"]) {\n        duration[\"year\"] = duration[\"y\"];\n        delete duration[\"y\"];\n    }\n    if (duration[\"mo\"]) {\n        duration[\"month\"] = duration[\"mo\"];\n        delete duration[\"mo\"];\n    }\n    if (duration[\"M\"]) {\n        duration[\"month\"] = duration[\"M\"];\n        delete duration[\"M\"];\n    }\n    if (duration[\"w\"]) {\n        duration[\"week\"] = duration[\"w\"];\n        delete duration[\"w\"];\n    }\n    if (duration[\"d\"]) {\n        duration[\"day\"] = duration[\"d\"];\n        delete duration[\"d\"];\n    }\n    if (duration[\"h\"]) {\n        duration[\"hour\"] = duration[\"h\"];\n        delete duration[\"h\"];\n    }\n    if (duration[\"m\"]) {\n        duration[\"minute\"] = duration[\"m\"];\n        delete duration[\"m\"];\n    }\n    if (duration[\"s\"]) {\n        duration[\"second\"] = duration[\"s\"];\n        delete duration[\"s\"];\n    }\n    if (duration[\"ms\"]) {\n        duration[\"millisecond\"] = duration[\"ms\"];\n        delete duration[\"ms\"];\n    }\n\n    if (\"year\" in duration) {\n        const floor = Math.floor(duration[\"year\"]);\n        date.setFullYear(date.getFullYear() + floor);\n        const remainingFraction = duration[\"year\"] - floor;\n        if (remainingFraction > 0) {\n            duration.month = duration?.month ?? 0;\n            duration.month += remainingFraction * 12;\n        }\n    }\n    if (\"quarter\" in duration) {\n        const floor = Math.floor(duration[\"quarter\"]);\n        date.setMonth(date.getMonth() + floor * 3);\n    }\n    if (\"month\" in duration) {\n        const floor = Math.floor(duration[\"month\"]);\n        date.setMonth(date.getMonth() + floor);\n        const remainingFraction = duration[\"month\"] - floor;\n        if (remainingFraction > 0) {\n            duration.week = duration?.week ?? 0;\n            duration.week += remainingFraction * 4;\n        }\n    }\n    if (\"week\" in duration) {\n        const floor = Math.floor(duration[\"week\"]);\n        date.setDate(date.getDate() + floor * 7);\n        const remainingFraction = duration[\"week\"] - floor;\n        if (remainingFraction > 0) {\n            duration.day = duration?.day ?? 0;\n            duration.day += Math.round(remainingFraction * 7);\n        }\n    }\n    if (\"day\" in duration) {\n        const floor = Math.floor(duration[\"day\"]);\n        date.setDate(date.getDate() + floor);\n        const remainingFraction = duration[\"day\"] - floor;\n        if (remainingFraction > 0) {\n            duration.hour = duration?.hour ?? 0;\n            duration.hour += Math.round(remainingFraction * 24);\n        }\n    }\n    if (\"hour\" in duration) {\n        const floor = Math.floor(duration[\"hour\"]);\n        date.setHours(date.getHours() + floor);\n        const remainingFraction = duration[\"hour\"] - floor;\n        if (remainingFraction > 0) {\n            duration.minute = duration?.minute ?? 0;\n            duration.minute += Math.round(remainingFraction * 60);\n        }\n    }\n    if (\"minute\" in duration) {\n        const floor = Math.floor(duration[\"minute\"]);\n        date.setMinutes(date.getMinutes() + floor);\n        const remainingFraction = duration[\"minute\"] - floor;\n        if (remainingFraction > 0) {\n            duration.second = duration?.second ?? 0;\n            duration.second += Math.round(remainingFraction * 60);\n        }\n    }\n    if (\"second\" in duration) {\n        const floor = Math.floor(duration[\"second\"]);\n        date.setSeconds(date.getSeconds() + floor);\n        const remainingFraction = duration[\"second\"] - floor;\n        if (remainingFraction > 0) {\n            duration.millisecond = duration?.millisecond ?? 0;\n            duration.millisecond += Math.round(remainingFraction * 1000);\n        }\n    }\n    if (\"millisecond\" in duration) {\n        const floor = Math.floor(duration[\"millisecond\"]);\n        date.setMilliseconds(date.getMilliseconds() + floor);\n    }\n    return date;\n}\n\n/**\n * Return the reversed duration (e.g. back into the past, instead of future)\n * @param duration\n */\nexport function reverseDuration(duration: Duration): Duration {\n    const reversed = {};\n    for (const key in duration) {\n        // noinspection JSUnfilteredForInLoop\n        reversed[key] = -duration[key];\n    }\n    return reversed as Duration;\n}\n", "type DictionaryLike = string[] | { [word: string]: unknown } | Map<string, unknown>;\n\nexport function repeatedTimeunitPattern(\n    prefix: string,\n    singleTimeunitPattern: string,\n    connectorPattern = \"\\\\s{0,5},?\\\\s{0,5}\"\n): string {\n    const singleTimeunitPatternNoCapture = singleTimeunitPattern.replace(/\\((?!\\?)/g, \"(?:\");\n    return `${prefix}${singleTimeunitPatternNoCapture}(?:${connectorPattern}${singleTimeunitPatternNoCapture}){0,10}`;\n}\n\nexport function extractTerms(dictionary: DictionaryLike): string[] {\n    let keys: string[];\n    if (dictionary instanceof Array) {\n        keys = [...dictionary];\n    } else if (dictionary instanceof Map) {\n        keys = Array.from((dictionary as Map<string, unknown>).keys());\n    } else {\n        keys = Object.keys(dictionary);\n    }\n\n    return keys;\n}\n\nexport function matchAnyPattern(dictionary: DictionaryLike): string {\n    // TODO: More efficient regex pattern by considering duplicated prefix\n\n    const joinedTerms = extractTerms(dictionary)\n        .sort((a, b) => b.length - a.length)\n        .join(\"|\")\n        .replace(/\\./g, \"\\\\.\");\n\n    return `(?:${joinedTerms})`;\n}\n", "import dayjs from \"dayjs\";\n\n/**\n * Find the most likely year, from a raw number. For example:\n * 1997 => 1997\n * 97 => 1997\n * 12 => 2012\n */\nexport function findMostLikelyADYear(yearNumber: number): number {\n    if (yearNumber < 100) {\n        if (yearNumber > 50) {\n            yearNumber = yearNumber + 1900;\n        } else {\n            yearNumber = yearNumber + 2000;\n        }\n    }\n\n    return yearNumber;\n}\n\nexport function findYearClosestToRef(refDate: Date, day: number, month: number): number {\n    //Find the most appropriated year\n    const refMoment = dayjs(refDate);\n    let dateMoment = refMoment;\n    dateMoment = dateMoment.month(month - 1);\n    dateMoment = dateMoment.date(day);\n    dateMoment = dateMoment.year(refMoment.year());\n\n    const nextYear = dateMoment.add(1, \"y\");\n    const lastYear = dateMoment.add(-1, \"y\");\n    if (Math.abs(nextYear.diff(refMoment)) < Math.abs(dateMoment.diff(refMoment))) {\n        dateMoment = nextYear;\n    } else if (Math.abs(lastYear.diff(refMoment)) < Math.abs(dateMoment.diff(refMoment))) {\n        dateMoment = lastYear;\n    }\n\n    return dateMoment.year();\n}\n", "import { OpUnitType, QUnitType } from \"dayjs\";\nimport { matchAnyPattern, repeatedTimeunitPattern } from \"../../utils/pattern\";\nimport { findMostLikelyADYear } from \"../../calculation/years\";\nimport { TimeUnits } from \"../../utils/timeunits\";\nimport { Weekday } from \"../../types\";\n\nexport const WEEKDAY_DICTIONARY: { [word: string]: Weekday } = {\n    sunday: 0,\n    sun: 0,\n    \"sun.\": 0,\n    monday: 1,\n    mon: 1,\n    \"mon.\": 1,\n    tuesday: 2,\n    tue: 2,\n    \"tue.\": 2,\n    wednesday: 3,\n    wed: 3,\n    \"wed.\": 3,\n    thursday: 4,\n    thurs: 4,\n    \"thurs.\": 4,\n    thur: 4,\n    \"thur.\": 4,\n    thu: 4,\n    \"thu.\": 4,\n    friday: 5,\n    fri: 5,\n    \"fri.\": 5,\n    saturday: 6,\n    sat: 6,\n    \"sat.\": 6,\n};\n\nexport const FULL_MONTH_NAME_DICTIONARY: { [word: string]: number } = {\n    january: 1,\n    february: 2,\n    march: 3,\n    april: 4,\n    may: 5,\n    june: 6,\n    july: 7,\n    august: 8,\n    september: 9,\n    october: 10,\n    november: 11,\n    december: 12,\n};\n\nexport const MONTH_DICTIONARY: { [word: string]: number } = {\n    ...FULL_MONTH_NAME_DICTIONARY,\n    jan: 1,\n    \"jan.\": 1,\n    feb: 2,\n    \"feb.\": 2,\n    mar: 3,\n    \"mar.\": 3,\n    apr: 4,\n    \"apr.\": 4,\n    jun: 6,\n    \"jun.\": 6,\n    jul: 7,\n    \"jul.\": 7,\n    aug: 8,\n    \"aug.\": 8,\n    sep: 9,\n    \"sep.\": 9,\n    sept: 9,\n    \"sept.\": 9,\n    oct: 10,\n    \"oct.\": 10,\n    nov: 11,\n    \"nov.\": 11,\n    dec: 12,\n    \"dec.\": 12,\n};\n\nexport const INTEGER_WORD_DICTIONARY: { [word: string]: number } = {\n    one: 1,\n    two: 2,\n    three: 3,\n    four: 4,\n    five: 5,\n    six: 6,\n    seven: 7,\n    eight: 8,\n    nine: 9,\n    ten: 10,\n    eleven: 11,\n    twelve: 12,\n};\n\nexport const ORDINAL_WORD_DICTIONARY: { [word: string]: number } = {\n    first: 1,\n    second: 2,\n    third: 3,\n    fourth: 4,\n    fifth: 5,\n    sixth: 6,\n    seventh: 7,\n    eighth: 8,\n    ninth: 9,\n    tenth: 10,\n    eleventh: 11,\n    twelfth: 12,\n    thirteenth: 13,\n    fourteenth: 14,\n    fifteenth: 15,\n    sixteenth: 16,\n    seventeenth: 17,\n    eighteenth: 18,\n    nineteenth: 19,\n    twentieth: 20,\n    \"twenty first\": 21,\n    \"twenty-first\": 21,\n    \"twenty second\": 22,\n    \"twenty-second\": 22,\n    \"twenty third\": 23,\n    \"twenty-third\": 23,\n    \"twenty fourth\": 24,\n    \"twenty-fourth\": 24,\n    \"twenty fifth\": 25,\n    \"twenty-fifth\": 25,\n    \"twenty sixth\": 26,\n    \"twenty-sixth\": 26,\n    \"twenty seventh\": 27,\n    \"twenty-seventh\": 27,\n    \"twenty eighth\": 28,\n    \"twenty-eighth\": 28,\n    \"twenty ninth\": 29,\n    \"twenty-ninth\": 29,\n    \"thirtieth\": 30,\n    \"thirty first\": 31,\n    \"thirty-first\": 31,\n};\n\nexport const TIME_UNIT_DICTIONARY_NO_ABBR: { [word: string]: OpUnitType | QUnitType } = {\n    second: \"second\",\n    seconds: \"second\",\n    minute: \"minute\",\n    minutes: \"minute\",\n    hour: \"hour\",\n    hours: \"hour\",\n    day: \"d\",\n    days: \"d\",\n    week: \"week\",\n    weeks: \"week\",\n    month: \"month\",\n    months: \"month\",\n    quarter: \"quarter\",\n    quarters: \"quarter\",\n    year: \"year\",\n    years: \"year\",\n};\n\nexport const TIME_UNIT_DICTIONARY: { [word: string]: OpUnitType | QUnitType } = {\n    s: \"second\",\n    sec: \"second\",\n    second: \"second\",\n    seconds: \"second\",\n    m: \"minute\",\n    min: \"minute\",\n    mins: \"minute\",\n    minute: \"minute\",\n    minutes: \"minute\",\n    h: \"hour\",\n    hr: \"hour\",\n    hrs: \"hour\",\n    hour: \"hour\",\n    hours: \"hour\",\n    d: \"d\",\n    day: \"d\",\n    days: \"d\",\n    w: \"w\",\n    week: \"week\",\n    weeks: \"week\",\n    mo: \"month\",\n    mon: \"month\",\n    mos: \"month\",\n    month: \"month\",\n    months: \"month\",\n    qtr: \"quarter\",\n    quarter: \"quarter\",\n    quarters: \"quarter\",\n    y: \"year\",\n    yr: \"year\",\n    year: \"year\",\n    years: \"year\",\n    // Also, merge the entries from the full-name dictionary.\n    // We leave the duplicated entries for readability.\n    ...TIME_UNIT_DICTIONARY_NO_ABBR,\n};\n\n//-----------------------------\n\nexport const NUMBER_PATTERN = `(?:${matchAnyPattern(\n    INTEGER_WORD_DICTIONARY\n)}|[0-9]+|[0-9]+\\\\.[0-9]+|half(?:\\\\s{0,2}an?)?|an?\\\\b(?:\\\\s{0,2}few)?|few|several|the|a?\\\\s{0,2}couple\\\\s{0,2}(?:of)?)`;\n\nexport function parseNumberPattern(match: string): number {\n    const num = match.toLowerCase();\n    if (INTEGER_WORD_DICTIONARY[num] !== undefined) {\n        return INTEGER_WORD_DICTIONARY[num];\n    } else if (num === \"a\" || num === \"an\" || num == \"the\") {\n        return 1;\n    } else if (num.match(/few/)) {\n        return 3;\n    } else if (num.match(/half/)) {\n        return 0.5;\n    } else if (num.match(/couple/)) {\n        return 2;\n    } else if (num.match(/several/)) {\n        return 7;\n    }\n\n    return parseFloat(num);\n}\n\n//-----------------------------\n\nexport const ORDINAL_NUMBER_PATTERN = `(?:${matchAnyPattern(ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:st|nd|rd|th)?)`;\nexport function parseOrdinalNumberPattern(match: string): number {\n    let num = match.toLowerCase();\n    if (ORDINAL_WORD_DICTIONARY[num] !== undefined) {\n        return ORDINAL_WORD_DICTIONARY[num];\n    }\n\n    num = num.replace(/(?:st|nd|rd|th)$/i, \"\");\n    return parseInt(num);\n}\n\n//-----------------------------\n\nexport const YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\\\s{0,2}(?:BE|AD|BC|BCE|CE)|[1-2][0-9]{3}|[5-9][0-9]|2[0-5])`;\nexport function parseYear(match: string): number {\n    if (/BE/i.test(match)) {\n        // Buddhist Era\n        match = match.replace(/BE/i, \"\");\n        return parseInt(match) - 543;\n    }\n\n    if (/BCE?/i.test(match)) {\n        // Before Christ, Before Common Era\n        match = match.replace(/BCE?/i, \"\");\n        return -parseInt(match);\n    }\n\n    if (/(AD|CE)/i.test(match)) {\n        // Anno Domini, Common Era\n        match = match.replace(/(AD|CE)/i, \"\");\n        return parseInt(match);\n    }\n\n    const rawYearNumber = parseInt(match);\n    return findMostLikelyADYear(rawYearNumber);\n}\n\n//-----------------------------\n\nconst SINGLE_TIME_UNIT_PATTERN = `(${NUMBER_PATTERN})\\\\s{0,3}(${matchAnyPattern(TIME_UNIT_DICTIONARY)})`;\nconst SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, \"i\");\n\nconst SINGLE_TIME_UNIT_NO_ABBR_PATTERN = `(${NUMBER_PATTERN})\\\\s{0,3}(${matchAnyPattern(\n    TIME_UNIT_DICTIONARY_NO_ABBR\n)})`;\n\nconst TIME_UNIT_CONNECTOR_PATTERN = `\\\\s{0,5},?(?:\\\\s*and)?\\\\s{0,5}`;\n\nexport const TIME_UNITS_PATTERN = repeatedTimeunitPattern(\n    `(?:(?:about|around)\\\\s{0,3})?`,\n    SINGLE_TIME_UNIT_PATTERN,\n    TIME_UNIT_CONNECTOR_PATTERN\n);\nexport const TIME_UNITS_NO_ABBR_PATTERN = repeatedTimeunitPattern(\n    `(?:(?:about|around)\\\\s{0,3})?`,\n    SINGLE_TIME_UNIT_NO_ABBR_PATTERN,\n    TIME_UNIT_CONNECTOR_PATTERN\n);\n\nexport function parseTimeUnits(timeunitText): null | TimeUnits {\n    const fragments = {};\n    let remainingText = timeunitText;\n    let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    while (match) {\n        collectDateTimeFragment(fragments, match);\n        remainingText = remainingText.substring(match[0].length).trim();\n        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    }\n    if (Object.keys(fragments).length == 0) {\n        return null;\n    }\n    return fragments;\n}\n\nfunction collectDateTimeFragment(fragments, match) {\n    if (match[0].match(/^[a-zA-Z]+$/)) {\n        return;\n    }\n    const num = parseNumberPattern(match[1]);\n    const unit = TIME_UNIT_DICTIONARY[match[2].toLowerCase()];\n    fragments[unit] = num;\n}\n", "import { Parser, ParsingContext } from \"../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../results\";\nimport { Component } from \"../../types\";\n\n/**\n * A parser that checks for word boundary and applying the inner pattern and extraction.\n */\nexport abstract class AbstractParserWithWordBoundaryChecking implements Parser {\n    abstract innerPattern(context: ParsingContext): RegExp;\n    abstract innerExtract(\n        context: ParsingContext,\n        match: RegExpMatchArray\n    ): ParsingComponents | ParsingResult | { [c in Component]?: number } | null;\n\n    // Overrides this method if there is more efficient way to check for inner pattern change.\n    innerPatternHasChange(context: ParsingContext, currentInnerPattern: RegExp): boolean {\n        return this.innerPattern(context) !== currentInnerPattern;\n    }\n\n    patternLeftBoundary(): string {\n        return `(\\\\W|^)`;\n    }\n\n    private cachedInnerPattern?: RegExp = null;\n    private cachedPattern?: RegExp = null;\n\n    pattern(context: ParsingContext): RegExp {\n        if (this.cachedInnerPattern) {\n            if (!this.innerPatternHasChange(context, this.cachedInnerPattern)) {\n                return this.cachedPattern;\n            }\n        }\n        this.cachedInnerPattern = this.innerPattern(context);\n        this.cachedPattern = new RegExp(\n            `${this.patternLeftBoundary()}${this.cachedInnerPattern.source}`,\n            this.cachedInnerPattern.flags\n        );\n        return this.cachedPattern;\n    }\n\n    extract(context: ParsingContext, match: RegExpMatchArray) {\n        const header = match[1] ?? \"\";\n        match.index = match.index + header.length;\n        match[0] = match[0].substring(header.length);\n        for (let i = 2; i < match.length; i++) {\n            match[i - 1] = match[i];\n        }\n\n        return this.innerExtract(context, match);\n    }\n}\n", "import { TIME_UNITS_PATTERN, parseTimeUnits, TIME_UNITS_NO_ABBR_PATTERN } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN_WITH_OPTIONAL_PREFIX = new RegExp(\n    `(?:(?:within|in|for)\\\\s*)?` +\n        `(?:(?:about|around|roughly|approximately|just)\\\\s*(?:~\\\\s*)?)?(${TIME_UNITS_PATTERN})(?=\\\\W|$)`,\n    \"i\"\n);\n\nconst PATTERN_WITH_PREFIX = new RegExp(\n    `(?:within|in|for)\\\\s*` +\n        `(?:(?:about|around|roughly|approximately|just)\\\\s*(?:~\\\\s*)?)?(${TIME_UNITS_PATTERN})(?=\\\\W|$)`,\n    \"i\"\n);\n\nconst PATTERN_WITH_PREFIX_STRICT = new RegExp(\n    `(?:within|in|for)\\\\s*` +\n        `(?:(?:about|around|roughly|approximately|just)\\\\s*(?:~\\\\s*)?)?(${TIME_UNITS_NO_ABBR_PATTERN})(?=\\\\W|$)`,\n    \"i\"\n);\n\nexport default class ENTimeUnitWithinFormatParser extends AbstractParserWithWordBoundaryChecking {\n    constructor(private strictMode: boolean) {\n        super();\n    }\n\n    innerPattern(context: ParsingContext): RegExp {\n        if (this.strictMode) {\n            return PATTERN_WITH_PREFIX_STRICT;\n        }\n        return context.option.forwardDate ? PATTERN_WITH_OPTIONAL_PREFIX : PATTERN_WITH_PREFIX;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        // Exclude \"for the unit\" phases, e.g. \"for the year\"\n        if (match[0].match(/^for\\s*the\\s*\\w+/)) {\n            return null;\n        }\n        const timeUnits = parseTimeUnits(match[1]);\n        if (!timeUnits) {\n            return null;\n        }\n        context.debug(() => {\n            console.log(timeUnits);\n            console.log(ParsingComponents.createRelativeFromReference(context.reference, timeUnits));\n        });\n\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingResult } from \"../../../results\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { ORDINAL_NUMBER_PATTERN, parseOrdinalNumberPattern } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\n// prettier-ignore\nconst PATTERN = new RegExp(\n    `(?:on\\\\s{0,3})?` +\n        `(${ORDINAL_NUMBER_PATTERN})` +\n        `(?:` +\n            `\\\\s{0,3}(?:to|\\\\-|\\\\\u2013|until|through|till)?\\\\s{0,3}` +\n            `(${ORDINAL_NUMBER_PATTERN})` +\n        \")?\" +\n        `(?:-|/|\\\\s{0,3}(?:of)?\\\\s{0,3})` +\n        `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n        \"(?:\" +\n            `(?:-|/|,?\\\\s{0,3})` +\n            `(${YEAR_PATTERN}(?!\\\\w))` +\n        \")?\" +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst DATE_GROUP = 1;\nconst DATE_TO_GROUP = 2;\nconst MONTH_NAME_GROUP = 3;\nconst YEAR_GROUP = 4;\n\nexport default class ENMonthNameLittleEndianParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseOrdinalNumberPattern(match[DATE_GROUP]);\n        if (day > 31) {\n            // e.g. \"[96 Aug]\" => \"9[6 Aug]\", we need to shift away from the next number\n            match.index = match.index + match[DATE_GROUP].length;\n            return null;\n        }\n\n        result.start.assign(\"month\", month);\n        result.start.assign(\"day\", day);\n\n        if (match[YEAR_GROUP]) {\n            const yearNumber = parseYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", yearNumber);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            result.start.imply(\"year\", year);\n        }\n\n        if (match[DATE_TO_GROUP]) {\n            const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);\n\n            result.end = result.start.clone();\n            result.end.assign(\"day\", endDate);\n        }\n\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { ORDINAL_NUMBER_PATTERN, parseOrdinalNumberPattern } from \"../constants\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\n// prettier-ignore\nconst PATTERN = new RegExp(\n    `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n        \"(?:-|/|\\\\s*,?\\\\s*)\" +\n        `(${ORDINAL_NUMBER_PATTERN})(?!\\\\s*(?:am|pm))\\\\s*` +\n        \"(?:\" +\n            \"(?:to|\\\\-)\\\\s*\" +\n            `(${ORDINAL_NUMBER_PATTERN})\\\\s*` +\n        \")?\" +\n        \"(?:\" +\n            `(?:-|/|\\\\s*,\\\\s*|\\\\s+)` +\n            `(${YEAR_PATTERN})` +\n        \")?\" +\n        \"(?=\\\\W|$)(?!\\\\:\\\\d)\",\n    \"i\"\n);\n\nconst MONTH_NAME_GROUP = 1;\nconst DATE_GROUP = 2;\nconst DATE_TO_GROUP = 3;\nconst YEAR_GROUP = 4;\n\n/**\n * The parser for parsing US's date format that begin with month's name.\n *  - January 13\n *  - January 13, 2012\n *  - January 13 - 15, 2012\n * Note: Watch out for:\n *  - January 12:00\n *  - January 12.44\n *  - January 1222344\n *  - January 21 (when shouldSkipYearLikeDate=true)\n */\nexport default class ENMonthNameMiddleEndianParser extends AbstractParserWithWordBoundaryChecking {\n    shouldSkipYearLikeDate: boolean;\n\n    constructor(shouldSkipYearLikeDate: boolean) {\n        super();\n        this.shouldSkipYearLikeDate = shouldSkipYearLikeDate;\n    }\n\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseOrdinalNumberPattern(match[DATE_GROUP]);\n        if (day > 31) {\n            return null;\n        }\n\n        // Skip the case where the day looks like a year (ex: January 21)\n        if (this.shouldSkipYearLikeDate) {\n            if (!match[DATE_TO_GROUP] && !match[YEAR_GROUP] && match[DATE_GROUP].match(/^2[0-5]$/)) {\n                return null;\n            }\n        }\n        const components = context\n            .createParsingComponents({\n                day: day,\n                month: month,\n            })\n            .addTag(\"parser/ENMonthNameMiddleEndianParser\");\n\n        if (match[YEAR_GROUP]) {\n            const year = parseYear(match[YEAR_GROUP]);\n            components.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            components.imply(\"year\", year);\n        }\n        if (!match[DATE_TO_GROUP]) {\n            return components;\n        }\n\n        // Text can be 'range' value. Such as 'January 12 - 13, 2012'\n        const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);\n        const result = context.createParsingResult(match.index, match[0]);\n        result.start = components;\n        result.end = components.clone();\n        result.end.assign(\"day\", endDate);\n\n        return result;\n    }\n}\n", "import { FULL_MONTH_NAME_DICTIONARY, MONTH_DICTIONARY } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    `((?:in)\\\\s*)?` +\n        `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n        `\\\\s*` +\n        `(?:` +\n        `(?:,|-|of)?\\\\s*(${YEAR_PATTERN})?` +\n        \")?\" +\n        \"(?=[^\\\\s\\\\w]|\\\\s+[^0-9]|\\\\s+$|$)\",\n    \"i\"\n);\n\nconst PREFIX_GROUP = 1;\nconst MONTH_NAME_GROUP = 2;\nconst YEAR_GROUP = 3;\n\n/**\n * The parser for parsing month name and year.\n * - January, 2012\n * - January 2012\n * - January\n * (in) Jan\n */\nexport default class ENMonthNameParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const monthName = match[MONTH_NAME_GROUP].toLowerCase();\n\n        // skip some unlikely words \"jan\", \"mar\", ..\n        if (match[0].length <= 3 && !FULL_MONTH_NAME_DICTIONARY[monthName]) {\n            return null;\n        }\n\n        const result = context.createParsingResult(\n            match.index + (match[PREFIX_GROUP] || \"\").length,\n            match.index + match[0].length\n        );\n        result.start.imply(\"day\", 1);\n        result.start.addTag(\"parser/ENMonthNameParser\");\n\n        const month = MONTH_DICTIONARY[monthName];\n        result.start.assign(\"month\", month);\n\n        if (match[YEAR_GROUP]) {\n            const year = parseYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.refDate, 1, month);\n            result.start.imply(\"year\", year);\n        }\n\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\n/*\n    Date format with slash \"/\" between numbers like ENSlashDateFormatParser,\n    but this parser expect year before month and date.\n    - YYYY/MM/DD\n    - YYYY-MM-DD\n    - YYYY.MM.DD\n*/\nconst PATTERN = new RegExp(\n    `([0-9]{4})[-\\\\.\\\\/\\\\s]` +\n        `(?:(${matchAnyPattern(MONTH_DICTIONARY)})|([0-9]{1,2}))[-\\\\.\\\\/\\\\s]` +\n        `([0-9]{1,2})` +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst YEAR_NUMBER_GROUP = 1;\nconst MONTH_NAME_GROUP = 2;\nconst MONTH_NUMBER_GROUP = 3;\nconst DATE_NUMBER_GROUP = 4;\n\nexport default class ENYearMonthDayParser extends AbstractParserWithWordBoundaryChecking {\n    constructor(private strictMonthDateOrder: boolean) {\n        super();\n    }\n\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const year = parseInt(match[YEAR_NUMBER_GROUP]);\n        let day = parseInt(match[DATE_NUMBER_GROUP]);\n        let month = match[MONTH_NUMBER_GROUP]\n            ? parseInt(match[MONTH_NUMBER_GROUP])\n            : MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n\n        if (month < 1 || month > 12) {\n            if (this.strictMonthDateOrder) {\n                return null;\n            }\n            if (day >= 1 && day <= 12) {\n                [month, day] = [day, month];\n            }\n        }\n        if (day < 1 || day > 31) {\n            return null;\n        }\n\n        return {\n            day: day,\n            month: month,\n            year: year,\n        };\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\"([0-9]|0[1-9]|1[012])/([0-9]{4})\" + \"\", \"i\");\n\nconst MONTH_GROUP = 1;\nconst YEAR_GROUP = 2;\n\n/**\n * Month/Year date format with slash \"/\" (also \"-\" and \".\") between numbers\n * - 11/05\n * - 06/2005\n */\nexport default class ENSlashMonthFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const year = parseInt(match[YEAR_GROUP]);\n        const month = parseInt(match[MONTH_GROUP]);\n\n        return context.createParsingComponents().imply(\"day\", 1).assign(\"month\", month).assign(\"year\", year);\n    }\n}\n", "import { Parser, ParsingContext } from \"../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../results\";\nimport { Meridiem } from \"../../types\";\n\n// prettier-ignore\nfunction primaryTimePattern(leftBoundary: string, primaryPrefix: string, primarySuffix: string, flags: string) {\n    return new RegExp(\n            `${leftBoundary}` +\n            `${primaryPrefix}` +\n            `(\\\\d{1,4})` +\n            `(?:` +\n                `(?:\\\\.|:|\uFF1A)` +\n                `(\\\\d{1,2})` +\n                `(?:` +\n                    `(?::|\uFF1A)` +\n                    `(\\\\d{2})` +\n                    `(?:\\\\.(\\\\d{1,6}))?` +\n                `)?` +\n            `)?` +\n            `(?:\\\\s*(a\\\\.m\\\\.|p\\\\.m\\\\.|am?|pm?))?` +\n            `${primarySuffix}`,\n        flags\n    );\n}\n\n// prettier-ignore\nfunction followingTimePatten(followingPhase: string, followingSuffix: string) {\n    return new RegExp(\n        `^(${followingPhase})` +\n            `(\\\\d{1,4})` +\n            `(?:` +\n                `(?:\\\\.|\\\\:|\\\\\uFF1A)` +\n                `(\\\\d{1,2})` +\n                `(?:` +\n                    `(?:\\\\.|\\\\:|\\\\\uFF1A)` +\n                    `(\\\\d{1,2})(?:\\\\.(\\\\d{1,6}))?` +\n                `)?` +\n            `)?` +\n            `(?:\\\\s*(a\\\\.m\\\\.|p\\\\.m\\\\.|am?|pm?))?` +\n            `${followingSuffix}`,\n        \"i\"\n    );\n}\n\nconst HOUR_GROUP = 2;\nconst MINUTE_GROUP = 3;\nconst SECOND_GROUP = 4;\nconst MILLI_SECOND_GROUP = 5;\nconst AM_PM_HOUR_GROUP = 6;\n\nexport abstract class AbstractTimeExpressionParser implements Parser {\n    abstract primaryPrefix(): string;\n    abstract followingPhase(): string;\n    strictMode: boolean;\n\n    constructor(strictMode = false) {\n        this.strictMode = strictMode;\n    }\n\n    patternFlags(): string {\n        return \"i\";\n    }\n\n    primaryPatternLeftBoundary(): string {\n        return `(^|\\\\s|T|\\\\b)`;\n    }\n\n    primarySuffix(): string {\n        return `(?!/)(?=\\\\W|$)`;\n    }\n\n    followingSuffix(): string {\n        return `(?!/)(?=\\\\W|$)`;\n    }\n\n    pattern(context: ParsingContext): RegExp {\n        return this.getPrimaryTimePatternThroughCache();\n    }\n\n    extract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const startComponents = this.extractPrimaryTimeComponents(context, match);\n        if (!startComponents) {\n            // If the match seem like a year e.g. \"2013.12:...\",\n            // then skips the year part and try matching again.\n            if (match[0].match(/^\\d{4}/)) {\n                match.index += 4; // Skip over potential overlapping pattern\n                return null;\n            }\n\n            match.index += match[0].length; // Skip over potential overlapping pattern\n            return null;\n        }\n\n        const index = match.index + match[1].length;\n        const text = match[0].substring(match[1].length);\n        const result = context.createParsingResult(index, text, startComponents);\n        match.index += match[0].length; // Skip over potential overlapping pattern\n\n        const remainingText = context.text.substring(match.index);\n        const followingPattern = this.getFollowingTimePatternThroughCache();\n        const followingMatch = followingPattern.exec(remainingText);\n\n        // Pattern \"456-12\", \"2022-12\" should not be time without proper context\n        if (text.match(/^\\d{3,4}/) && followingMatch) {\n            // e.g. \"2022-12\"\n            if (followingMatch[0].match(/^\\s*([+-])\\s*\\d{2,4}$/)) {\n                return null;\n            }\n            // e.g. \"2022-12:01...\"\n            if (followingMatch[0].match(/^\\s*([+-])\\s*\\d{2}\\W\\d{2}/)) {\n                return null;\n            }\n        }\n\n        if (\n            !followingMatch ||\n            // Pattern \"YY.YY -XXXX\" is more like timezone offset\n            followingMatch[0].match(/^\\s*([+-])\\s*\\d{3,4}$/)\n        ) {\n            return this.checkAndReturnWithoutFollowingPattern(result);\n        }\n\n        result.end = this.extractFollowingTimeComponents(context, followingMatch, result);\n        if (result.end) {\n            result.text += followingMatch[0];\n        }\n\n        return this.checkAndReturnWithFollowingPattern(result);\n    }\n\n    extractPrimaryTimeComponents(\n        context: ParsingContext,\n        match: RegExpMatchArray,\n        strict = false\n    ): null | ParsingComponents {\n        const components = context.createParsingComponents();\n        let minute = 0;\n        let meridiem = null;\n\n        // ----- Hours\n        let hour = parseInt(match[HOUR_GROUP]);\n        if (hour > 100) {\n            if (this.strictMode || match[MINUTE_GROUP] != null) {\n                return null;\n            }\n\n            minute = hour % 100;\n            hour = Math.floor(hour / 100);\n        }\n\n        if (hour > 24) {\n            return null;\n        }\n\n        // ----- Minutes\n        if (match[MINUTE_GROUP] != null) {\n            if (match[MINUTE_GROUP].length == 1 && !match[AM_PM_HOUR_GROUP]) {\n                // Skip single digit minute e.g. \"at 1.1 xx\"\n                return null;\n            }\n\n            minute = parseInt(match[MINUTE_GROUP]);\n        }\n\n        if (minute >= 60) {\n            return null;\n        }\n\n        if (hour > 12) {\n            meridiem = Meridiem.PM;\n        }\n\n        // ----- AM & PM\n        if (match[AM_PM_HOUR_GROUP] != null) {\n            if (hour > 12) return null;\n            const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();\n            if (ampm == \"a\") {\n                meridiem = Meridiem.AM;\n                if (hour == 12) {\n                    hour = 0;\n                }\n            }\n\n            if (ampm == \"p\") {\n                meridiem = Meridiem.PM;\n                if (hour != 12) {\n                    hour += 12;\n                }\n            }\n        }\n\n        components.assign(\"hour\", hour);\n        components.assign(\"minute\", minute);\n\n        if (meridiem !== null) {\n            components.assign(\"meridiem\", meridiem);\n        } else {\n            if (hour < 12) {\n                components.imply(\"meridiem\", Meridiem.AM);\n            } else {\n                components.imply(\"meridiem\", Meridiem.PM);\n            }\n        }\n\n        // ----- Millisecond\n        if (match[MILLI_SECOND_GROUP] != null) {\n            const millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));\n            if (millisecond >= 1000) return null;\n\n            components.assign(\"millisecond\", millisecond);\n        }\n\n        // ----- Second\n        if (match[SECOND_GROUP] != null) {\n            const second = parseInt(match[SECOND_GROUP]);\n            if (second >= 60) return null;\n\n            components.assign(\"second\", second);\n        }\n\n        return components;\n    }\n\n    extractFollowingTimeComponents(\n        context: ParsingContext,\n        match: RegExpMatchArray,\n        result: ParsingResult\n    ): null | ParsingComponents {\n        const components = context.createParsingComponents();\n\n        // ----- Millisecond\n        if (match[MILLI_SECOND_GROUP] != null) {\n            const millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));\n            if (millisecond >= 1000) return null;\n\n            components.assign(\"millisecond\", millisecond);\n        }\n\n        // ----- Second\n        if (match[SECOND_GROUP] != null) {\n            const second = parseInt(match[SECOND_GROUP]);\n            if (second >= 60) return null;\n\n            components.assign(\"second\", second);\n        }\n\n        let hour = parseInt(match[HOUR_GROUP]);\n        let minute = 0;\n        let meridiem = -1;\n\n        // ----- Minute\n        if (match[MINUTE_GROUP] != null) {\n            minute = parseInt(match[MINUTE_GROUP]);\n        } else if (hour > 100) {\n            minute = hour % 100;\n            hour = Math.floor(hour / 100);\n        }\n\n        if (minute >= 60 || hour > 24) {\n            return null;\n        }\n\n        if (hour >= 12) {\n            meridiem = Meridiem.PM;\n        }\n\n        // ----- AM & PM\n        if (match[AM_PM_HOUR_GROUP] != null) {\n            if (hour > 12) {\n                return null;\n            }\n\n            const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();\n            if (ampm == \"a\") {\n                meridiem = Meridiem.AM;\n                if (hour == 12) {\n                    hour = 0;\n                    if (!components.isCertain(\"day\")) {\n                        components.imply(\"day\", components.get(\"day\") + 1);\n                    }\n                }\n            }\n\n            if (ampm == \"p\") {\n                meridiem = Meridiem.PM;\n                if (hour != 12) hour += 12;\n            }\n\n            if (!result.start.isCertain(\"meridiem\")) {\n                if (meridiem == Meridiem.AM) {\n                    result.start.imply(\"meridiem\", Meridiem.AM);\n\n                    if (result.start.get(\"hour\") == 12) {\n                        result.start.assign(\"hour\", 0);\n                    }\n                } else {\n                    result.start.imply(\"meridiem\", Meridiem.PM);\n\n                    if (result.start.get(\"hour\") != 12) {\n                        result.start.assign(\"hour\", result.start.get(\"hour\") + 12);\n                    }\n                }\n            }\n        }\n\n        components.assign(\"hour\", hour);\n        components.assign(\"minute\", minute);\n\n        if (meridiem >= 0) {\n            components.assign(\"meridiem\", meridiem);\n        } else {\n            const startAtPM = result.start.isCertain(\"meridiem\") && result.start.get(\"hour\") > 12;\n            if (startAtPM) {\n                if (result.start.get(\"hour\") - 12 > hour) {\n                    // 10pm - 1 (am)\n                    components.imply(\"meridiem\", Meridiem.AM);\n                } else if (hour <= 12) {\n                    components.assign(\"hour\", hour + 12);\n                    components.assign(\"meridiem\", Meridiem.PM);\n                }\n            } else if (hour > 12) {\n                components.imply(\"meridiem\", Meridiem.PM);\n            } else if (hour <= 12) {\n                components.imply(\"meridiem\", Meridiem.AM);\n            }\n        }\n\n        if (components.date().getTime() < result.start.date().getTime()) {\n            components.imply(\"day\", components.get(\"day\") + 1);\n        }\n\n        return components;\n    }\n\n    private checkAndReturnWithoutFollowingPattern(result) {\n        // Single digit (e.g \"1\") should not be counted as time expression (without proper context)\n        if (result.text.match(/^\\d$/)) {\n            return null;\n        }\n\n        // Three or more digit (e.g. \"203\", \"2014\") should not be counted as time expression (without proper context)\n        if (result.text.match(/^\\d\\d\\d+$/)) {\n            return null;\n        }\n\n        // Instead of \"am/pm\", it ends with \"a\" or \"p\" (e.g \"1a\", \"123p\"), this seems unlikely\n        if (result.text.match(/\\d[apAP]$/)) {\n            return null;\n        }\n\n        // If it ends only with numbers or dots\n        const endingWithNumbers = result.text.match(/[^\\d:.](\\d[\\d.]+)$/);\n        if (endingWithNumbers) {\n            const endingNumbers: string = endingWithNumbers[1];\n\n            // In strict mode (e.g. \"at 1\" or \"at 1.2\"), this should not be accepted\n            if (this.strictMode) {\n                return null;\n            }\n\n            // If it ends only with dot single digit, e.g. \"at 1.2\"\n            if (endingNumbers.includes(\".\") && !endingNumbers.match(/\\d(\\.\\d{2})+$/)) {\n                return null;\n            }\n\n            // If it ends only with numbers above 24, e.g. \"at 25\"\n            const endingNumberVal = parseInt(endingNumbers);\n            if (endingNumberVal > 24) {\n                return null;\n            }\n        }\n\n        return result;\n    }\n\n    private checkAndReturnWithFollowingPattern(result) {\n        if (result.text.match(/^\\d+-\\d+$/)) {\n            return null;\n        }\n\n        // If it ends only with numbers or dots\n        const endingWithNumbers = result.text.match(/[^\\d:.](\\d[\\d.]+)\\s*-\\s*(\\d[\\d.]+)$/);\n        if (endingWithNumbers) {\n            // In strict mode (e.g. \"at 1-3\" or \"at 1.2 - 2.3\"), this should not be accepted\n            if (this.strictMode) {\n                return null;\n            }\n\n            const startingNumbers: string = endingWithNumbers[1];\n            const endingNumbers: string = endingWithNumbers[2];\n            // If it ends only with dot single digit, e.g. \"at 1.2\"\n            if (endingNumbers.includes(\".\") && !endingNumbers.match(/\\d(\\.\\d{2})+$/)) {\n                return null;\n            }\n\n            // If it ends only with numbers above 24, e.g. \"at 25\"\n            const endingNumberVal = parseInt(endingNumbers);\n            const startingNumberVal = parseInt(startingNumbers);\n            if (endingNumberVal > 24 || startingNumberVal > 24) {\n                return null;\n            }\n        }\n\n        return result;\n    }\n\n    private cachedPrimaryPrefix = null;\n    private cachedPrimarySuffix = null;\n    private cachedPrimaryTimePattern = null;\n\n    getPrimaryTimePatternThroughCache() {\n        const primaryPrefix = this.primaryPrefix();\n        const primarySuffix = this.primarySuffix();\n\n        if (this.cachedPrimaryPrefix === primaryPrefix && this.cachedPrimarySuffix === primarySuffix) {\n            return this.cachedPrimaryTimePattern;\n        }\n\n        this.cachedPrimaryTimePattern = primaryTimePattern(\n            this.primaryPatternLeftBoundary(),\n            primaryPrefix,\n            primarySuffix,\n            this.patternFlags()\n        );\n        this.cachedPrimaryPrefix = primaryPrefix;\n        this.cachedPrimarySuffix = primarySuffix;\n        return this.cachedPrimaryTimePattern;\n    }\n\n    private cachedFollowingPhase = null;\n    private cachedFollowingSuffix = null;\n    private cachedFollowingTimePatten = null;\n\n    getFollowingTimePatternThroughCache() {\n        const followingPhase = this.followingPhase();\n        const followingSuffix = this.followingSuffix();\n\n        if (this.cachedFollowingPhase === followingPhase && this.cachedFollowingSuffix === followingSuffix) {\n            return this.cachedFollowingTimePatten;\n        }\n\n        this.cachedFollowingTimePatten = followingTimePatten(followingPhase, followingSuffix);\n        this.cachedFollowingPhase = followingPhase;\n        this.cachedFollowingSuffix = followingSuffix;\n        return this.cachedFollowingTimePatten;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport { Meridiem } from \"../../../types\";\nimport { AbstractTimeExpressionParser } from \"../../../common/parsers/AbstractTimeExpressionParser\";\n\nexport default class ENTimeExpressionParser extends AbstractTimeExpressionParser {\n    constructor(strictMode) {\n        super(strictMode);\n    }\n\n    followingPhase(): string {\n        return \"\\\\s*(?:\\\\-|\\\\\u2013|\\\\~|\\\\\u301C|to|until|through|till|\\\\?)\\\\s*\";\n    }\n\n    primaryPrefix(): string {\n        return \"(?:(?:at|from)\\\\s*)??\";\n    }\n\n    primarySuffix(): string {\n        return \"(?:\\\\s*(?:o\\\\W*clock|at\\\\s*night|in\\\\s*the\\\\s*(?:morning|afternoon)))?(?!/)(?=\\\\W|$)\";\n    }\n\n    extractPrimaryTimeComponents(context: ParsingContext, match: RegExpMatchArray): null | ParsingComponents {\n        const components = super.extractPrimaryTimeComponents(context, match);\n        if (!components) {\n            return components;\n        }\n\n        if (match[0].endsWith(\"night\")) {\n            const hour = components.get(\"hour\");\n            if (hour >= 6 && hour < 12) {\n                components.assign(\"hour\", components.get(\"hour\") + 12);\n                components.assign(\"meridiem\", Meridiem.PM);\n            } else if (hour < 6) {\n                components.assign(\"meridiem\", Meridiem.AM);\n            }\n        }\n\n        if (match[0].endsWith(\"afternoon\")) {\n            components.assign(\"meridiem\", Meridiem.PM);\n            const hour = components.get(\"hour\");\n            if (hour >= 0 && hour <= 6) {\n                components.assign(\"hour\", components.get(\"hour\") + 12);\n            }\n        }\n\n        if (match[0].endsWith(\"morning\")) {\n            components.assign(\"meridiem\", Meridiem.AM);\n            const hour = components.get(\"hour\");\n            if (hour < 12) {\n                components.assign(\"hour\", components.get(\"hour\"));\n            }\n        }\n\n        return components.addTag(\"parser/ENTimeExpressionParser\");\n    }\n\n    extractFollowingTimeComponents(\n        context: ParsingContext,\n        match: RegExpMatchArray,\n        result: ParsingResult\n    ): ParsingComponents | null {\n        const followingComponents = super.extractFollowingTimeComponents(context, match, result);\n        if (followingComponents) {\n            followingComponents.addTag(\"parser/ENTimeExpressionParser\");\n        }\n        return followingComponents;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { parseTimeUnits, TIME_UNITS_NO_ABBR_PATTERN, TIME_UNITS_PATTERN } from \"../constants\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { reverseDuration } from \"../../../calculation/duration\";\n\nconst PATTERN = new RegExp(`(${TIME_UNITS_PATTERN})\\\\s{0,5}(?:ago|before|earlier)(?=\\\\W|$)`, \"i\");\nconst STRICT_PATTERN = new RegExp(`(${TIME_UNITS_NO_ABBR_PATTERN})\\\\s{0,5}(?:ago|before|earlier)(?=\\\\W|$)`, \"i\");\n\nexport default class ENTimeUnitAgoFormatParser extends AbstractParserWithWordBoundaryChecking {\n    constructor(private strictMode: boolean) {\n        super();\n    }\n\n    innerPattern(): RegExp {\n        return this.strictMode ? STRICT_PATTERN : PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const duration = parseTimeUnits(match[1]);\n        if (!duration) {\n            return null;\n        }\n        return ParsingComponents.createRelativeFromReference(context.reference, reverseDuration(duration));\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { parseTimeUnits, TIME_UNITS_NO_ABBR_PATTERN, TIME_UNITS_PATTERN } from \"../constants\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    `(${TIME_UNITS_PATTERN})\\\\s{0,5}(?:later|after|from now|henceforth|forward|out)` + \"(?=(?:\\\\W|$))\",\n    \"i\"\n);\n\nconst STRICT_PATTERN = new RegExp(`(${TIME_UNITS_NO_ABBR_PATTERN})\\\\s{0,5}(later|after|from now)(?=\\\\W|$)`, \"i\");\nconst GROUP_NUM_TIMEUNITS = 1;\n\nexport default class ENTimeUnitLaterFormatParser extends AbstractParserWithWordBoundaryChecking {\n    constructor(private strictMode: boolean) {\n        super();\n    }\n\n    innerPattern(): RegExp {\n        return this.strictMode ? STRICT_PATTERN : PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const timeUnits = parseTimeUnits(match[GROUP_NUM_TIMEUNITS]);\n        if (!timeUnits) {\n            return null;\n        }\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "import { ParsingContext, Refiner } from \"../chrono\";\nimport { ParsingResult } from \"../results\";\n\n/**\n * A special type of {@link Refiner} to filter the results\n */\nexport abstract class Filter implements Refiner {\n    abstract isValid(context: ParsingContext, result: ParsingResult): boolean;\n\n    refine(context: ParsingContext, results: ParsingResult[]): ParsingResult[] {\n        return results.filter((r) => this.isValid(context, r));\n    }\n}\n\n/**\n * A special type of {@link Refiner} to merge consecutive results\n */\nexport abstract class MergingRefiner implements Refiner {\n    abstract shouldMergeResults(\n        textBetween: string,\n        currentResult: ParsingResult,\n        nextResult: ParsingResult,\n        context: ParsingContext\n    ): boolean;\n\n    abstract mergeResults(\n        textBetween: string,\n        currentResult: ParsingResult,\n        nextResult: ParsingResult,\n        context: ParsingContext\n    ): ParsingResult;\n\n    refine(context: ParsingContext, results: ParsingResult[]): ParsingResult[] {\n        if (results.length < 2) {\n            return results;\n        }\n\n        const mergedResults: ParsingResult[] = [];\n        let curResult = results[0];\n        let nextResult = null;\n\n        for (let i = 1; i < results.length; i++) {\n            nextResult = results[i];\n\n            const textBetween = context.text.substring(curResult.index + curResult.text.length, nextResult.index);\n            if (!this.shouldMergeResults(textBetween, curResult, nextResult, context)) {\n                mergedResults.push(curResult);\n                curResult = nextResult;\n            } else {\n                const left = curResult;\n                const right = nextResult;\n                const mergedResult = this.mergeResults(textBetween, left, right, context);\n                context.debug(() => {\n                    console.log(`${this.constructor.name} merged ${left} and ${right} into ${mergedResult}`);\n                });\n\n                curResult = mergedResult;\n            }\n        }\n\n        if (curResult != null) {\n            mergedResults.push(curResult);\n        }\n\n        return mergedResults;\n    }\n}\n", "/*\n  \n*/\n\nimport { ParsingResult } from \"../../results\";\nimport { MergingRefiner } from \"../abstractRefiners\";\n\nexport default abstract class AbstractMergeDateRangeRefiner extends MergingRefiner {\n    abstract patternBetween(): RegExp;\n\n    shouldMergeResults(textBetween, currentResult, nextResult): boolean {\n        return !currentResult.end && !nextResult.end && textBetween.match(this.patternBetween()) != null;\n    }\n\n    mergeResults(textBetween, fromResult, toResult): ParsingResult {\n        if (!fromResult.start.isOnlyWeekdayComponent() && !toResult.start.isOnlyWeekdayComponent()) {\n            toResult.start.getCertainComponents().forEach((key) => {\n                if (!fromResult.start.isCertain(key)) {\n                    fromResult.start.imply(key, toResult.start.get(key));\n                }\n            });\n\n            fromResult.start.getCertainComponents().forEach((key) => {\n                if (!toResult.start.isCertain(key)) {\n                    toResult.start.imply(key, fromResult.start.get(key));\n                }\n            });\n        }\n\n        if (fromResult.start.date().getTime() > toResult.start.date().getTime()) {\n            let fromMoment = fromResult.start.dayjs();\n            let toMoment = toResult.start.dayjs();\n            if (toResult.start.isOnlyWeekdayComponent() && toMoment.add(7, \"days\").isAfter(fromMoment)) {\n                toMoment = toMoment.add(7, \"days\");\n                toResult.start.imply(\"day\", toMoment.date());\n                toResult.start.imply(\"month\", toMoment.month() + 1);\n                toResult.start.imply(\"year\", toMoment.year());\n            } else if (fromResult.start.isOnlyWeekdayComponent() && fromMoment.add(-7, \"days\").isBefore(toMoment)) {\n                fromMoment = fromMoment.add(-7, \"days\");\n                fromResult.start.imply(\"day\", fromMoment.date());\n                fromResult.start.imply(\"month\", fromMoment.month() + 1);\n                fromResult.start.imply(\"year\", fromMoment.year());\n            } else if (toResult.start.isDateWithUnknownYear() && toMoment.add(1, \"years\").isAfter(fromMoment)) {\n                toMoment = toMoment.add(1, \"years\");\n                toResult.start.imply(\"year\", toMoment.year());\n            } else if (fromResult.start.isDateWithUnknownYear() && fromMoment.add(-1, \"years\").isBefore(toMoment)) {\n                fromMoment = fromMoment.add(-1, \"years\");\n                fromResult.start.imply(\"year\", fromMoment.year());\n            } else {\n                [toResult, fromResult] = [fromResult, toResult];\n            }\n        }\n\n        const result = fromResult.clone();\n        result.start = fromResult.start;\n        result.end = toResult.start;\n        result.index = Math.min(fromResult.index, toResult.index);\n        if (fromResult.index < toResult.index) {\n            result.text = fromResult.text + textBetween + toResult.text;\n        } else {\n            result.text = toResult.text + textBetween + fromResult.text;\n        }\n\n        return result;\n    }\n}\n", "/*\n  \n*/\n\nimport AbstractMergeDateRangeRefiner from \"../../../common/refiners/AbstractMergeDateRangeRefiner\";\n\n/**\n * Merging before and after results (see. AbstractMergeDateRangeRefiner)\n * This implementation should provide English connecting phases\n * - 2020-02-13 [to] 2020-02-13\n * - Wednesday [-] Friday\n */\nexport default class ENMergeDateRangeRefiner extends AbstractMergeDateRangeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*(to|-|\u2013|until|through|till)\\s*$/i;\n    }\n}\n", "import { ParsingComponents } from \"../results\";\nimport dayjs from \"dayjs\";\nimport { Meridiem } from \"../types\";\n\nexport function assignTheNextDay(component: ParsingComponents, targetDayJs: dayjs.Dayjs) {\n    targetDayJs = targetDayJs.add(1, \"day\");\n    assignSimilarDate(component, targetDayJs);\n    implySimilarTime(component, targetDayJs);\n}\n\nexport function implyTheNextDay(component: ParsingComponents, targetDayJs: dayjs.Dayjs) {\n    targetDayJs = targetDayJs.add(1, \"day\");\n    implySimilarDate(component, targetDayJs);\n    implySimilarTime(component, targetDayJs);\n}\n\nexport function assignSimilarDate(component: ParsingComponents, targetDayJs: dayjs.Dayjs) {\n    component.assign(\"day\", targetDayJs.date());\n    component.assign(\"month\", targetDayJs.month() + 1);\n    component.assign(\"year\", targetDayJs.year());\n}\n\nexport function assignSimilarTime(component: ParsingComponents, targetDayJs: dayjs.Dayjs) {\n    component.assign(\"hour\", targetDayJs.hour());\n    component.assign(\"minute\", targetDayJs.minute());\n    component.assign(\"second\", targetDayJs.second());\n    component.assign(\"millisecond\", targetDayJs.millisecond());\n    if (component.get(\"hour\") < 12) {\n        component.assign(\"meridiem\", Meridiem.AM);\n    } else {\n        component.assign(\"meridiem\", Meridiem.PM);\n    }\n}\n\n/**\n * @deprecated Use `dates.implySimilarDate` with normal Javascript Date instead.\n */\nexport function implySimilarDate(component: ParsingComponents, targetDayJs: dayjs.Dayjs) {\n    component.imply(\"day\", targetDayJs.date());\n    component.imply(\"month\", targetDayJs.month() + 1);\n    component.imply(\"year\", targetDayJs.year());\n}\n\n/**\n * @deprecated Use `dates.implySimilarTime` with normal Javascript Date instead.\n */\nexport function implySimilarTime(component: ParsingComponents, targetDayJs: dayjs.Dayjs) {\n    component.imply(\"hour\", targetDayJs.hour());\n    component.imply(\"minute\", targetDayJs.minute());\n    component.imply(\"second\", targetDayJs.second());\n    component.imply(\"millisecond\", targetDayJs.millisecond());\n}\n", "import { ParsingComponents, ParsingResult } from \"../results\";\nimport { Meridiem } from \"../types\";\nimport { assignSimilarDate, implySimilarDate } from \"../utils/dayjs\";\n\nexport function mergeDateTimeResult(dateResult: ParsingResult, timeResult: ParsingResult): ParsingResult {\n    const result = dateResult.clone();\n    const beginDate = dateResult.start;\n    const beginTime = timeResult.start;\n\n    result.start = mergeDateTimeComponent(beginDate, beginTime);\n    if (dateResult.end != null || timeResult.end != null) {\n        const endDate = dateResult.end == null ? dateResult.start : dateResult.end;\n        const endTime = timeResult.end == null ? timeResult.start : timeResult.end;\n        const endDateTime = mergeDateTimeComponent(endDate, endTime);\n\n        if (dateResult.end == null && endDateTime.date().getTime() < result.start.date().getTime()) {\n            // For example,  \"Tuesday 9pm - 1am\" the ending should actually be 1am on the next day.\n            // We need to add to ending by another day.\n            const nextDayJs = endDateTime.dayjs().add(1, \"day\");\n            if (endDateTime.isCertain(\"day\")) {\n                assignSimilarDate(endDateTime, nextDayJs);\n            } else {\n                implySimilarDate(endDateTime, nextDayJs);\n            }\n        }\n\n        result.end = endDateTime;\n    }\n\n    return result;\n}\n\nexport function mergeDateTimeComponent(\n    dateComponent: ParsingComponents,\n    timeComponent: ParsingComponents\n): ParsingComponents {\n    const dateTimeComponent = dateComponent.clone();\n\n    if (timeComponent.isCertain(\"hour\")) {\n        dateTimeComponent.assign(\"hour\", timeComponent.get(\"hour\"));\n        dateTimeComponent.assign(\"minute\", timeComponent.get(\"minute\"));\n\n        if (timeComponent.isCertain(\"second\")) {\n            dateTimeComponent.assign(\"second\", timeComponent.get(\"second\"));\n\n            if (timeComponent.isCertain(\"millisecond\")) {\n                dateTimeComponent.assign(\"millisecond\", timeComponent.get(\"millisecond\"));\n            } else {\n                dateTimeComponent.imply(\"millisecond\", timeComponent.get(\"millisecond\"));\n            }\n        } else {\n            dateTimeComponent.imply(\"second\", timeComponent.get(\"second\"));\n            dateTimeComponent.imply(\"millisecond\", timeComponent.get(\"millisecond\"));\n        }\n    } else {\n        dateTimeComponent.imply(\"hour\", timeComponent.get(\"hour\"));\n        dateTimeComponent.imply(\"minute\", timeComponent.get(\"minute\"));\n        dateTimeComponent.imply(\"second\", timeComponent.get(\"second\"));\n        dateTimeComponent.imply(\"millisecond\", timeComponent.get(\"millisecond\"));\n    }\n\n    if (timeComponent.isCertain(\"timezoneOffset\")) {\n        dateTimeComponent.assign(\"timezoneOffset\", timeComponent.get(\"timezoneOffset\"));\n    }\n\n    if (timeComponent.isCertain(\"meridiem\")) {\n        dateTimeComponent.assign(\"meridiem\", timeComponent.get(\"meridiem\"));\n    } else if (timeComponent.get(\"meridiem\") != null && dateTimeComponent.get(\"meridiem\") == null) {\n        dateTimeComponent.imply(\"meridiem\", timeComponent.get(\"meridiem\"));\n    }\n\n    if (dateTimeComponent.get(\"meridiem\") == Meridiem.PM && dateTimeComponent.get(\"hour\") < 12) {\n        if (timeComponent.isCertain(\"hour\")) {\n            dateTimeComponent.assign(\"hour\", dateTimeComponent.get(\"hour\") + 12);\n        } else {\n            dateTimeComponent.imply(\"hour\", dateTimeComponent.get(\"hour\") + 12);\n        }\n    }\n\n    dateTimeComponent.addTags(dateComponent.tags());\n    dateTimeComponent.addTags(timeComponent.tags());\n    return dateTimeComponent;\n}\n", "/*\n\n*/\n\nimport { MergingRefiner } from \"../abstractRefiners\";\nimport { ParsingResult } from \"../../results\";\nimport { mergeDateTimeResult } from \"../../calculation/mergingCalculation\";\n\nexport default abstract class AbstractMergeDateTimeRefiner extends MergingRefiner {\n    abstract patternBetween(): RegExp;\n\n    shouldMergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): boolean {\n        return (\n            ((currentResult.start.isOnlyDate() && nextResult.start.isOnlyTime()) ||\n                (nextResult.start.isOnlyDate() && currentResult.start.isOnlyTime())) &&\n            textBetween.match(this.patternBetween()) != null\n        );\n    }\n\n    mergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): ParsingResult {\n        const result = currentResult.start.isOnlyDate()\n            ? mergeDateTimeResult(currentResult, nextResult)\n            : mergeDateTimeResult(nextResult, currentResult);\n\n        result.index = currentResult.index;\n        result.text = currentResult.text + textBetween + nextResult.text;\n        return result;\n    }\n}\n", "import AbstractMergeDateTimeRefiner from \"../../../common/refiners/AbstractMergeDateTimeRefiner\";\n\n/**\n * Merging date-only result and time-only result (see. AbstractMergeDateTimeRefiner).\n * This implementation should provide English connecting phases\n * - 2020-02-13 [at] 6pm\n * - Tomorrow [after] 7am\n */\nexport default class ENMergeDateTimeRefiner extends AbstractMergeDateTimeRefiner {\n    patternBetween(): RegExp {\n        return new RegExp(\"^\\\\s*(T|at|after|before|on|of|,|-|\\\\.|\u2219|:)?\\\\s*$\");\n    }\n}\n", "// Map ABBR -> Offset in minute\nimport { ParsingContext, Refiner } from \"../../chrono\";\nimport { TimezoneAbbrMap } from \"../../types\";\nimport { ParsingResult } from \"../../results\";\nimport { toTimezoneOffset } from \"../../timezone\";\n\nconst TIMEZONE_NAME_PATTERN = new RegExp(\"^\\\\s*,?\\\\s*\\\\(?([A-Z]{2,4})\\\\)?(?=\\\\W|$)\", \"i\");\n\nexport default class ExtractTimezoneAbbrRefiner implements Refiner {\n    constructor(private readonly timezoneOverrides?: TimezoneAbbrMap) {}\n\n    refine(context: ParsingContext, results: ParsingResult[]): ParsingResult[] {\n        const timezoneOverrides = context.option.timezones ?? {};\n\n        results.forEach((result) => {\n            const suffix = context.text.substring(result.index + result.text.length);\n            const match = TIMEZONE_NAME_PATTERN.exec(suffix);\n            if (!match) {\n                return;\n            }\n\n            const timezoneAbbr = match[1].toUpperCase();\n            const refDate = result.start.date() ?? result.refDate ?? new Date();\n            const tzOverrides = { ...this.timezoneOverrides, ...timezoneOverrides };\n            const extractedTimezoneOffset = toTimezoneOffset(timezoneAbbr, refDate, tzOverrides);\n            if (extractedTimezoneOffset == null) {\n                return;\n            }\n            context.debug(() => {\n                console.log(\n                    `Extracting timezone: '${timezoneAbbr}' into: ${extractedTimezoneOffset} for: ${result.start}`\n                );\n            });\n\n            const currentTimezoneOffset = result.start.get(\"timezoneOffset\");\n            if (currentTimezoneOffset !== null && extractedTimezoneOffset != currentTimezoneOffset) {\n                // We may already have extracted the timezone offset e.g. \"11 am GMT+0900 (JST)\"\n                // - if they are equal, we also want to take the abbreviation text into result\n                // - if they are not equal, we trust the offset more\n                if (result.start.isCertain(\"timezoneOffset\")) {\n                    return;\n                }\n\n                // This is often because it's relative time with inferred timezone (e.g. in 1 hour, tomorrow)\n                // Then, we want to double-check the abbr case (e.g. \"GET\" not \"get\")\n                if (timezoneAbbr != match[1]) {\n                    return;\n                }\n            }\n\n            if (result.start.isOnlyDate()) {\n                // If the time is not explicitly mentioned,\n                // Then, we also want to double-check the abbr case (e.g. \"GET\" not \"get\")\n                if (timezoneAbbr != match[1]) {\n                    return;\n                }\n            }\n\n            result.text += match[0];\n\n            if (!result.start.isCertain(\"timezoneOffset\")) {\n                result.start.assign(\"timezoneOffset\", extractedTimezoneOffset);\n            }\n\n            if (result.end != null && !result.end.isCertain(\"timezoneOffset\")) {\n                result.end.assign(\"timezoneOffset\", extractedTimezoneOffset);\n            }\n        });\n\n        return results;\n    }\n}\n", "import { ParsingContext, Refiner } from \"../../chrono\";\nimport { ParsingResult } from \"../../results\";\n\nconst TIMEZONE_OFFSET_PATTERN = new RegExp(\"^\\\\s*(?:\\\\(?(?:GMT|UTC)\\\\s?)?([+-])(\\\\d{1,2})(?::?(\\\\d{2}))?\\\\)?\", \"i\");\nconst TIMEZONE_OFFSET_SIGN_GROUP = 1;\nconst TIMEZONE_OFFSET_HOUR_OFFSET_GROUP = 2;\nconst TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP = 3;\n\nexport default class ExtractTimezoneOffsetRefiner implements Refiner {\n    refine(context: ParsingContext, results: ParsingResult[]): ParsingResult[] {\n        results.forEach(function (result) {\n            if (result.start.isCertain(\"timezoneOffset\")) {\n                return;\n            }\n\n            const suffix = context.text.substring(result.index + result.text.length);\n            const match = TIMEZONE_OFFSET_PATTERN.exec(suffix);\n            if (!match) {\n                return;\n            }\n\n            context.debug(() => {\n                console.log(`Extracting timezone: '${match[0]}' into : ${result}`);\n            });\n\n            const hourOffset = parseInt(match[TIMEZONE_OFFSET_HOUR_OFFSET_GROUP]);\n            const minuteOffset = parseInt(match[TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP] || \"0\");\n            let timezoneOffset = hourOffset * 60 + minuteOffset;\n            // No timezones have offsets greater than 14 hours, so disregard this match\n            if (timezoneOffset > 14 * 60) {\n                return;\n            }\n            if (match[TIMEZONE_OFFSET_SIGN_GROUP] === \"-\") {\n                timezoneOffset = -timezoneOffset;\n            }\n\n            if (result.end != null) {\n                result.end.assign(\"timezoneOffset\", timezoneOffset);\n            }\n\n            result.start.assign(\"timezoneOffset\", timezoneOffset);\n            result.text += match[0];\n        });\n\n        return results;\n    }\n}\n", "/*\n  \n*/\n\nimport { ParsingContext, Refiner } from \"../../chrono\";\nimport { ParsingResult } from \"../../results\";\n\nexport default class OverlapRemovalRefiner implements Refiner {\n    refine(context: ParsingContext, results: ParsingResult[]): ParsingResult[] {\n        if (results.length < 2) {\n            return results;\n        }\n\n        const filteredResults = [];\n        let prevResult = results[0];\n        for (let i = 1; i < results.length; i++) {\n            const result = results[i];\n            if (result.index >= prevResult.index + prevResult.text.length) {\n                filteredResults.push(prevResult);\n                prevResult = result;\n                continue;\n            }\n\n            // If overlap, compare the length and discard the shorter one\n            let kept = null;\n            let removed = null;\n            if (result.text.length > prevResult.text.length) {\n                kept = result;\n                removed = prevResult;\n            } else {\n                kept = prevResult;\n                removed = result;\n            }\n            context.debug(() => {\n                console.log(`${this.constructor.name} remove ${removed} by ${kept}`);\n            });\n            prevResult = kept;\n        }\n\n        // The last one\n        if (prevResult != null) {\n            filteredResults.push(prevResult);\n        }\n\n        return filteredResults;\n    }\n}\n", "/*\n    Enforce 'forwardDate' option to on the results. When there are missing component,\n    e.g. \"March 12-13 (without year)\" or \"Thursday\", the refiner will try to adjust the result\n    into the future instead of the past.\n*/\n\nimport { ParsingContext, Refiner } from \"../../chrono\";\nimport { ParsingResult } from \"../../results\";\nimport dayjs from \"dayjs\";\nimport * as dates from \"../../utils/dates\";\n\nexport default class ForwardDateRefiner implements Refiner {\n    refine(context: ParsingContext, results: ParsingResult[]): ParsingResult[] {\n        if (!context.option.forwardDate) {\n            return results;\n        }\n\n        results.forEach((result) => {\n            let refMoment = dayjs(context.reference.getDateWithAdjustedTimezone());\n\n            if (result.start.isOnlyTime() && context.reference.instant > result.start.date()) {\n                const refDate = context.reference.getDateWithAdjustedTimezone();\n                const refFollowingDay = new Date(refDate);\n                refFollowingDay.setDate(refFollowingDay.getDate() + 1);\n\n                dates.implySimilarDate(result.start, refFollowingDay);\n                context.debug(() => {\n                    console.log(\n                        `${this.constructor.name} adjusted ${result} time from the ref date (${refDate}) to the following day (${refFollowingDay})`\n                    );\n                });\n                if (result.end && result.end.isOnlyTime()) {\n                    dates.implySimilarDate(result.end, refFollowingDay);\n                    if (result.start.date() > result.end.date()) {\n                        refFollowingDay.setDate(refFollowingDay.getDate() + 1);\n                        dates.implySimilarDate(result.end, refFollowingDay);\n                    }\n                }\n            }\n\n            if (result.start.isOnlyWeekdayComponent() && refMoment.isAfter(result.start.dayjs())) {\n                if (refMoment.day() >= result.start.get(\"weekday\")) {\n                    refMoment = refMoment.day(result.start.get(\"weekday\") + 7);\n                } else {\n                    refMoment = refMoment.day(<number>result.start.get(\"weekday\"));\n                }\n\n                result.start.imply(\"day\", refMoment.date());\n                result.start.imply(\"month\", refMoment.month() + 1);\n                result.start.imply(\"year\", refMoment.year());\n                context.debug(() => {\n                    console.log(`${this.constructor.name} adjusted ${result} weekday (${result.start})`);\n                });\n\n                if (result.end && result.end.isOnlyWeekdayComponent()) {\n                    // Adjust date to the coming week\n                    if (refMoment.day() > result.end.get(\"weekday\")) {\n                        refMoment = refMoment.day(result.end.get(\"weekday\") + 7);\n                    } else {\n                        refMoment = refMoment.day(<number>result.end.get(\"weekday\"));\n                    }\n\n                    result.end.imply(\"day\", refMoment.date());\n                    result.end.imply(\"month\", refMoment.month() + 1);\n                    result.end.imply(\"year\", refMoment.year());\n                    context.debug(() => {\n                        console.log(`${this.constructor.name} adjusted ${result} weekday (${result.end})`);\n                    });\n                }\n            }\n\n            // In case where we know the month, but not which year (e.g. \"in December\", \"25th December\"),\n            // try move to another year\n            if (result.start.isDateWithUnknownYear() && refMoment.isAfter(result.start.dayjs())) {\n                for (let i = 0; i < 3 && refMoment.isAfter(result.start.dayjs()); i++) {\n                    result.start.imply(\"year\", result.start.get(\"year\") + 1);\n                    context.debug(() => {\n                        console.log(`${this.constructor.name} adjusted ${result} year (${result.start})`);\n                    });\n\n                    if (result.end && !result.end.isCertain(\"year\")) {\n                        result.end.imply(\"year\", result.end.get(\"year\") + 1);\n                        context.debug(() => {\n                            console.log(`${this.constructor.name} adjusted ${result} month (${result.start})`);\n                        });\n                    }\n                }\n            }\n        });\n\n        return results;\n    }\n}\n", "import { Filter } from \"../abstractRefiners\";\nimport { ParsingResult } from \"../../results\";\n\nexport default class UnlikelyFormatFilter extends Filter {\n    constructor(private strictMode: boolean) {\n        super();\n    }\n\n    isValid(context, result: ParsingResult): boolean {\n        if (result.text.replace(\" \", \"\").match(/^\\d*(\\.\\d*)?$/)) {\n            context.debug(() => {\n                console.log(`Removing unlikely result '${result.text}'`);\n            });\n\n            return false;\n        }\n\n        if (!result.start.isValidDate()) {\n            context.debug(() => {\n                console.log(`Removing invalid result: ${result} (${result.start})`);\n            });\n\n            return false;\n        }\n\n        if (result.end && !result.end.isValidDate()) {\n            context.debug(() => {\n                console.log(`Removing invalid result: ${result} (${result.end})`);\n            });\n\n            return false;\n        }\n\n        if (this.strictMode) {\n            return this.isStrictModeValid(context, result);\n        }\n\n        return true;\n    }\n\n    private isStrictModeValid(context, result: ParsingResult) {\n        if (result.start.isOnlyWeekdayComponent()) {\n            context.debug(() => {\n                console.log(`(Strict) Removing weekday only component: ${result} (${result.end})`);\n            });\n\n            return false;\n        }\n\n        return true;\n    }\n}\n", "import { ParsingContext } from \"../../chrono\";\nimport { Component } from \"../../types\";\nimport { AbstractParserWithWordBoundaryChecking } from \"./AbstractParserWithWordBoundary\";\n\n// ISO 8601\n// http://www.w3.org/TR/NOTE-datetime\n// - YYYY-MM-DD\n// - YYYY-MM-DDThh:mmTZD\n// - YYYY-MM-DDThh:mm:ssTZD\n// - YYYY-MM-DDThh:mm:ss.sTZD\n// - TZD = (Z or +hh:mm or -hh:mm)\n\n// prettier-ignore\nconst PATTERN = new RegExp(\n    \"([0-9]{4})\\\\-([0-9]{1,2})\\\\-([0-9]{1,2})\" +\n    \"(?:T\" + //..\n        \"([0-9]{1,2}):([0-9]{1,2})\" + // hh:mm\n        \"(?:\" +\n            \":([0-9]{1,2})(?:\\\\.(\\\\d{1,4}))?\" +\n        \")?\" + // :ss.s\n        \"(\" +\n            \"Z|([+-]\\\\d{2}):?(\\\\d{2})?\" +\n        \")?\" + // TZD (Z or \u00B1hh:mm or \u00B1hhmm or \u00B1hh)\n    \")?\" +\n    \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst YEAR_NUMBER_GROUP = 1;\nconst MONTH_NUMBER_GROUP = 2;\nconst DATE_NUMBER_GROUP = 3;\nconst HOUR_NUMBER_GROUP = 4;\nconst MINUTE_NUMBER_GROUP = 5;\nconst SECOND_NUMBER_GROUP = 6;\nconst MILLISECOND_NUMBER_GROUP = 7;\nconst TZD_GROUP = 8;\nconst TZD_HOUR_OFFSET_GROUP = 9;\nconst TZD_MINUTE_OFFSET_GROUP = 10;\n\nexport default class ISOFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const components = context.createParsingComponents({\n            \"year\": parseInt(match[YEAR_NUMBER_GROUP]),\n            \"month\": parseInt(match[MONTH_NUMBER_GROUP]),\n            \"day\": parseInt(match[DATE_NUMBER_GROUP]),\n        });\n        if (match[HOUR_NUMBER_GROUP] != null) {\n            components.assign(\"hour\", parseInt(match[HOUR_NUMBER_GROUP]));\n            components.assign(\"minute\", parseInt(match[MINUTE_NUMBER_GROUP]));\n\n            if (match[SECOND_NUMBER_GROUP] != null) {\n                components.assign(\"second\", parseInt(match[SECOND_NUMBER_GROUP]));\n            }\n\n            if (match[MILLISECOND_NUMBER_GROUP] != null) {\n                components.assign(\"millisecond\", parseInt(match[MILLISECOND_NUMBER_GROUP]));\n            }\n            if (match[TZD_GROUP] != null) {\n                // The Zulu time zone (Z) is equivalent to UTC\n                let offset = 0;\n                if (match[TZD_HOUR_OFFSET_GROUP]) {\n                    const hourOffset = parseInt(match[TZD_HOUR_OFFSET_GROUP]);\n                    let minuteOffset = 0;\n                    if (match[TZD_MINUTE_OFFSET_GROUP] != null) {\n                        minuteOffset = parseInt(match[TZD_MINUTE_OFFSET_GROUP]);\n                    }\n                    offset = hourOffset * 60;\n                    if (offset < 0) {\n                        offset -= minuteOffset;\n                    } else {\n                        offset += minuteOffset;\n                    }\n                }\n                components.assign(\"timezoneOffset\", offset);\n            }\n        }\n        return components.addTag(\"parser/ISOFormatParser\");\n    }\n}\n", "/*\n  \n*/\n\nimport { MergingRefiner } from \"../abstractRefiners\";\nimport { ParsingResult } from \"../../results\";\n\n/**\n * Merge weekday component into more completed data\n * - [Sunday] [12/7/2014] => [Sunday 12/7/2014]\n * - [Tuesday], [January 13, 2012] => [Sunday 12/7/2014]\n */\nexport default class MergeWeekdayComponentRefiner extends MergingRefiner {\n    mergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): ParsingResult {\n        const newResult = nextResult.clone();\n        newResult.index = currentResult.index;\n        newResult.text = currentResult.text + textBetween + newResult.text;\n\n        newResult.start.assign(\"weekday\", currentResult.start.get(\"weekday\"));\n        if (newResult.end) {\n            newResult.end.assign(\"weekday\", currentResult.start.get(\"weekday\"));\n        }\n\n        return newResult;\n    }\n\n    shouldMergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): boolean {\n        const weekdayThenNormalDate =\n            currentResult.start.isOnlyWeekdayComponent() &&\n            !currentResult.start.isCertain(\"hour\") &&\n            nextResult.start.isCertain(\"day\");\n        return weekdayThenNormalDate && textBetween.match(/^,?\\s*$/) != null;\n    }\n}\n", "import { Configuration, Parser, Refiner } from \"./chrono\";\n\nimport ExtractTimezoneAbbrRefiner from \"./common/refiners/ExtractTimezoneAbbrRefiner\";\nimport ExtractTimezoneOffsetRefiner from \"./common/refiners/ExtractTimezoneOffsetRefiner\";\nimport OverlapRemovalRefiner from \"./common/refiners/OverlapRemovalRefiner\";\nimport ForwardDateRefiner from \"./common/refiners/ForwardDateRefiner\";\nimport UnlikelyFormatFilter from \"./common/refiners/UnlikelyFormatFilter\";\nimport ISOFormatParser from \"./common/parsers/ISOFormatParser\";\nimport MergeWeekdayComponentRefiner from \"./common/refiners/MergeWeekdayComponentRefiner\";\n\nexport function includeCommonConfiguration(configuration: Configuration, strictMode = false): Configuration {\n    configuration.parsers.unshift(new ISOFormatParser());\n\n    configuration.refiners.unshift(new MergeWeekdayComponentRefiner());\n    configuration.refiners.unshift(new ExtractTimezoneOffsetRefiner());\n    configuration.refiners.unshift(new OverlapRemovalRefiner());\n\n    // Unlike ExtractTimezoneOffsetRefiner, this refiner relies on knowing both date and time in cases where the tz\n    // is ambiguous (in terms of DST/non-DST). It therefore needs to be applied as late as possible in the parsing.\n    configuration.refiners.push(new ExtractTimezoneAbbrRefiner());\n    configuration.refiners.push(new OverlapRemovalRefiner());\n    configuration.refiners.push(new ForwardDateRefiner());\n    configuration.refiners.push(new UnlikelyFormatFilter(strictMode));\n    return configuration;\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport dayjs from \"dayjs\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { assignSimilarDate } from \"../../../utils/dayjs\";\nimport * as references from \"../../../common/casualReferences\";\n\nconst PATTERN = /(now|today|tonight|tomorrow|overmorrow|tmr|tmrw|yesterday|last\\s*night)(?=\\W|$)/i;\n\nexport default class ENCasualDateParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        let targetDate = dayjs(context.refDate);\n        const lowerText = match[0].toLowerCase();\n        let component = context.createParsingComponents();\n\n        switch (lowerText) {\n            case \"now\":\n                component = references.now(context.reference);\n                break;\n\n            case \"today\":\n                component = references.today(context.reference);\n                break;\n\n            case \"yesterday\":\n                component = references.yesterday(context.reference);\n                break;\n\n            case \"tomorrow\":\n            case \"tmr\":\n            case \"tmrw\":\n                component = references.tomorrow(context.reference);\n                break;\n\n            case \"tonight\":\n                component = references.tonight(context.reference);\n                break;\n\n            case \"overmorrow\":\n                component = references.theDayAfter(context.reference, 2);\n                break;\n\n            default:\n                if (lowerText.match(/last\\s*night/)) {\n                    if (targetDate.hour() > 6) {\n                        targetDate = targetDate.add(-1, \"day\");\n                    }\n\n                    assignSimilarDate(component, targetDate);\n                    component.imply(\"hour\", 0);\n                }\n                break;\n        }\n        component.addTag(\"parser/ENCasualDateParser\");\n        return component;\n    }\n}\n", "import { ParsingComponents, ReferenceWithTimezone } from \"../results\";\nimport dayjs from \"dayjs\";\nimport {\n    assignSimilarDate,\n    assignSimilarTime,\n    implySimilarDate,\n    implySimilarTime,\n    implyTheNextDay,\n} from \"../utils/dayjs\";\nimport { Meridiem } from \"../types\";\n\nexport function now(reference: ReferenceWithTimezone): ParsingComponents {\n    const targetDate = dayjs(reference.getDateWithAdjustedTimezone());\n    const component = new ParsingComponents(reference, {});\n    assignSimilarDate(component, targetDate);\n    assignSimilarTime(component, targetDate);\n    component.assign(\"timezoneOffset\", reference.getTimezoneOffset());\n    component.addTag(\"casualReference/now\");\n    return component;\n}\n\nexport function today(reference: ReferenceWithTimezone): ParsingComponents {\n    const targetDate = dayjs(reference.getDateWithAdjustedTimezone());\n    const component = new ParsingComponents(reference, {});\n    assignSimilarDate(component, targetDate);\n    implySimilarTime(component, targetDate);\n    component.addTag(\"casualReference/today\");\n    return component;\n}\n\n/**\n * The previous day. Imply the same time.\n */\nexport function yesterday(reference: ReferenceWithTimezone): ParsingComponents {\n    return theDayBefore(reference, 1).addTag(\"casualReference/yesterday\");\n}\n\nexport function theDayBefore(reference: ReferenceWithTimezone, numDay: number): ParsingComponents {\n    return theDayAfter(reference, -numDay);\n}\n\n/**\n * The following day with dayjs.assignTheNextDay()\n */\nexport function tomorrow(reference: ReferenceWithTimezone): ParsingComponents {\n    return theDayAfter(reference, 1).addTag(\"casualReference/tomorrow\");\n}\n\nexport function theDayAfter(reference: ReferenceWithTimezone, nDays: number): ParsingComponents {\n    let targetDate = dayjs(reference.getDateWithAdjustedTimezone());\n    const component = new ParsingComponents(reference, {});\n    targetDate = targetDate.add(nDays, \"day\");\n    assignSimilarDate(component, targetDate);\n    implySimilarTime(component, targetDate);\n    return component;\n}\n\nexport function tonight(reference: ReferenceWithTimezone, implyHour = 22): ParsingComponents {\n    const targetDate = dayjs(reference.getDateWithAdjustedTimezone());\n    const component = new ParsingComponents(reference, {});\n    assignSimilarDate(component, targetDate);\n    component.imply(\"hour\", implyHour);\n    component.imply(\"meridiem\", Meridiem.PM);\n    component.addTag(\"casualReference/tonight\");\n    return component;\n}\n\nexport function lastNight(reference: ReferenceWithTimezone, implyHour = 0): ParsingComponents {\n    let targetDate = dayjs(reference.getDateWithAdjustedTimezone());\n    const component = new ParsingComponents(reference, {});\n    if (targetDate.hour() < 6) {\n        targetDate = targetDate.add(-1, \"day\");\n    }\n    assignSimilarDate(component, targetDate);\n    component.imply(\"hour\", implyHour);\n    return component;\n}\n\nexport function evening(reference: ReferenceWithTimezone, implyHour = 20): ParsingComponents {\n    const component = new ParsingComponents(reference, {});\n    component.imply(\"meridiem\", Meridiem.PM);\n    component.imply(\"hour\", implyHour);\n    component.addTag(\"casualReference/evening\");\n    return component;\n}\n\nexport function yesterdayEvening(reference: ReferenceWithTimezone, implyHour = 20): ParsingComponents {\n    let targetDate = dayjs(reference.getDateWithAdjustedTimezone());\n    const component = new ParsingComponents(reference, {});\n    targetDate = targetDate.add(-1, \"day\");\n    assignSimilarDate(component, targetDate);\n    component.imply(\"hour\", implyHour);\n    component.imply(\"meridiem\", Meridiem.PM);\n    component.addTag(\"casualReference/yesterday\");\n    component.addTag(\"casualReference/evening\");\n    return component;\n}\n\nexport function midnight(reference: ReferenceWithTimezone): ParsingComponents {\n    const component = new ParsingComponents(reference, {});\n    const targetDate = dayjs(reference.getDateWithAdjustedTimezone());\n    if (targetDate.hour() > 2) {\n        // Unless it's very early morning (0~2AM), we assume the midnight is the coming midnight.\n        // Thus, increasing the day by 1.\n        implyTheNextDay(component, targetDate);\n    }\n    component.assign(\"hour\", 0);\n    component.imply(\"minute\", 0);\n    component.imply(\"second\", 0);\n    component.imply(\"millisecond\", 0);\n    component.addTag(\"casualReference/midnight\");\n    return component;\n}\n\nexport function morning(reference: ReferenceWithTimezone, implyHour = 6): ParsingComponents {\n    const component = new ParsingComponents(reference, {});\n    component.imply(\"meridiem\", Meridiem.AM);\n    component.imply(\"hour\", implyHour);\n    component.imply(\"minute\", 0);\n    component.imply(\"second\", 0);\n    component.imply(\"millisecond\", 0);\n    component.addTag(\"casualReference/morning\");\n    return component;\n}\n\nexport function afternoon(reference: ReferenceWithTimezone, implyHour = 15): ParsingComponents {\n    const component = new ParsingComponents(reference, {});\n    component.imply(\"meridiem\", Meridiem.PM);\n    component.imply(\"hour\", implyHour);\n    component.imply(\"minute\", 0);\n    component.imply(\"second\", 0);\n    component.imply(\"millisecond\", 0);\n    component.addTag(\"casualReference/afternoon\");\n    return component;\n}\n\nexport function noon(reference: ReferenceWithTimezone): ParsingComponents {\n    const component = new ParsingComponents(reference, {});\n    component.imply(\"meridiem\", Meridiem.AM);\n    component.assign(\"hour\", 12);\n    component.imply(\"minute\", 0);\n    component.imply(\"second\", 0);\n    component.imply(\"millisecond\", 0);\n    component.addTag(\"casualReference/noon\");\n    return component;\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport * as casualReferences from \"../../../common/casualReferences\";\n\nconst PATTERN = /(?:this)?\\s{0,3}(morning|afternoon|evening|night|midnight|midday|noon)(?=\\W|$)/i;\n\nexport default class ENCasualTimeParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern() {\n        return PATTERN;\n    }\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        let component = null;\n        switch (match[1].toLowerCase()) {\n            case \"afternoon\":\n                component = casualReferences.afternoon(context.reference);\n                break;\n            case \"evening\":\n            case \"night\":\n                component = casualReferences.evening(context.reference);\n                break;\n            case \"midnight\":\n                component = casualReferences.midnight(context.reference);\n                break;\n            case \"morning\":\n                component = casualReferences.morning(context.reference);\n                break;\n            case \"noon\":\n            case \"midday\":\n                component = casualReferences.noon(context.reference);\n                break;\n        }\n        if (component) {\n            component.addTag(\"parser/ENCasualTimeParser\");\n        }\n        return component;\n    }\n}\n", "import { OpUnitType, QUnitType } from \"dayjs\";\nimport { ParsingComponents } from \"../results\";\n\n/**\n * @deprecated Use `calculation.duration.Duration`.\n */\nexport type TimeUnits = { [c in OpUnitType | QUnitType]?: number };\n\n/**\n * @deprecated Use `calculation.duration.*`.\n */\nexport function reverseTimeUnits(timeUnits: TimeUnits): TimeUnits {\n    const reversed = {};\n    for (const key in timeUnits) {\n        // noinspection JSUnfilteredForInLoop\n        reversed[key] = -timeUnits[key];\n    }\n\n    return reversed as TimeUnits;\n}\n\n/**\n * @deprecated Use `calculation.duration.*`.\n */\nexport function addImpliedTimeUnits(components: ParsingComponents, timeUnits: TimeUnits): ParsingComponents {\n    const output = components.clone();\n\n    let date = components.dayjs();\n    for (const key in timeUnits) {\n        // noinspection JSUnfilteredForInLoop,TypeScriptValidateTypes\n        date = date.add(timeUnits[key], key as QUnitType);\n    }\n\n    if (\"day\" in timeUnits || \"d\" in timeUnits || \"week\" in timeUnits || \"month\" in timeUnits || \"year\" in timeUnits) {\n        output.imply(\"day\", date.date());\n        output.imply(\"month\", date.month() + 1);\n        output.imply(\"year\", date.year());\n    }\n\n    if (\"second\" in timeUnits || \"minute\" in timeUnits || \"hour\" in timeUnits) {\n        output.imply(\"second\", date.second());\n        output.imply(\"minute\", date.minute());\n        output.imply(\"hour\", date.hour());\n    }\n\n    return output;\n}\n", "import { Weekday } from \"../types\";\nimport { ParsingComponents, ReferenceWithTimezone } from \"../results\";\nimport { addImpliedTimeUnits } from \"../utils/timeunits\";\n\n/**\n * Returns the parsing components at the weekday (considering the modifier). The time and timezone is assume to be\n * similar to the reference.\n * @param reference\n * @param weekday\n * @param modifier \"this\", \"next\", \"last\" modifier word. If empty, returns the weekday closest to the `refDate`.\n */\nexport function createParsingComponentsAtWeekday(\n    reference: ReferenceWithTimezone,\n    weekday: Weekday,\n    modifier?: \"this\" | \"next\" | \"last\"\n): ParsingComponents {\n    const refDate = reference.getDateWithAdjustedTimezone();\n    const daysToWeekday = getDaysToWeekday(refDate, weekday, modifier);\n\n    let components = new ParsingComponents(reference);\n    components = addImpliedTimeUnits(components, { \"day\": daysToWeekday });\n    components.assign(\"weekday\", weekday);\n\n    return components;\n}\n\n/**\n * Returns number of days from refDate to the weekday. The refDate date and timezone information is used.\n * @param refDate\n * @param weekday\n * @param modifier \"this\", \"next\", \"last\" modifier word. If empty, returns the weekday closest to the `refDate`.\n */\nexport function getDaysToWeekday(refDate: Date, weekday: Weekday, modifier?: \"this\" | \"next\" | \"last\"): number {\n    const refWeekday = refDate.getDay() as Weekday;\n    switch (modifier) {\n        case \"this\":\n            return getDaysForwardToWeekday(refDate, weekday);\n        case \"last\":\n            return getBackwardDaysToWeekday(refDate, weekday);\n        case \"next\":\n            // From Sunday, the next Sunday is 7 days later.\n            // Otherwise, next Mon is 1 days later, next Tues is 2 days later, and so on..., (return enum value)\n            if (refWeekday == Weekday.SUNDAY) {\n                return weekday == Weekday.SUNDAY ? 7 : weekday;\n            }\n            // From Saturday, the next Saturday is 7 days later, the next Sunday is 8-days later.\n            // Otherwise, next Mon is (1 + 1) days later, next Tues is (1 + 2) days later, and so on...,\n            // (return, 2 + [enum value] days)\n            if (refWeekday == Weekday.SATURDAY) {\n                if (weekday == Weekday.SATURDAY) return 7;\n                if (weekday == Weekday.SUNDAY) return 8;\n                return 1 + weekday;\n            }\n            // From weekdays, next Mon is the following week's Mon, next Tues the following week's Tues, and so on...\n            // If the week's weekday already passed (weekday < refWeekday), we simply count forward to next week\n            // (similar to 'this'). Otherwise, count forward to this week, then add another 7 days.\n            if (weekday < refWeekday && weekday != Weekday.SUNDAY) {\n                return getDaysForwardToWeekday(refDate, weekday);\n            } else {\n                return getDaysForwardToWeekday(refDate, weekday) + 7;\n            }\n    }\n    return getDaysToWeekdayClosest(refDate, weekday);\n}\n\nexport function getDaysToWeekdayClosest(refDate: Date, weekday: Weekday): number {\n    const backward = getBackwardDaysToWeekday(refDate, weekday);\n    const forward = getDaysForwardToWeekday(refDate, weekday);\n\n    return forward < -backward ? forward : backward;\n}\n\nexport function getDaysForwardToWeekday(refDate: Date, weekday: Weekday): number {\n    const refWeekday = refDate.getDay();\n    let forwardCount = weekday - refWeekday;\n    if (forwardCount < 0) {\n        forwardCount += 7;\n    }\n    return forwardCount;\n}\n\nexport function getBackwardDaysToWeekday(refDate: Date, weekday: Weekday): number {\n    const refWeekday = refDate.getDay();\n    let backwardCount = weekday - refWeekday;\n    if (backwardCount >= 0) {\n        backwardCount -= 7;\n    }\n    return backwardCount;\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { WEEKDAY_DICTIONARY } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { createParsingComponentsAtWeekday } from \"../../../calculation/weekdays\";\nimport { Weekday } from \"../../../types\";\n\nconst PATTERN = new RegExp(\n    \"(?:(?:\\\\,|\\\\(|\\\\\uFF08)\\\\s*)?\" +\n        \"(?:on\\\\s*?)?\" +\n        \"(?:(this|last|past|next)\\\\s*)?\" +\n        `(${matchAnyPattern(WEEKDAY_DICTIONARY)}|weekend|weekday)` +\n        \"(?:\\\\s*(?:\\\\,|\\\\)|\\\\\uFF09))?\" +\n        \"(?:\\\\s*(this|last|past|next)\\\\s*week)?\" +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst PREFIX_GROUP = 1;\nconst WEEKDAY_GROUP = 2;\nconst POSTFIX_GROUP = 3;\n\nexport default class ENWeekdayParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | null {\n        const prefix = match[PREFIX_GROUP];\n        const postfix = match[POSTFIX_GROUP];\n        let modifierWord = prefix || postfix;\n        modifierWord = modifierWord || \"\";\n        modifierWord = modifierWord.toLowerCase();\n\n        let modifier = null;\n        if (modifierWord == \"last\" || modifierWord == \"past\") {\n            modifier = \"last\";\n        } else if (modifierWord == \"next\") {\n            modifier = \"next\";\n        } else if (modifierWord == \"this\") {\n            modifier = \"this\";\n        }\n\n        const weekday_word = match[WEEKDAY_GROUP].toLowerCase();\n        let weekday;\n        if (WEEKDAY_DICTIONARY[weekday_word] !== undefined) {\n            weekday = WEEKDAY_DICTIONARY[weekday_word];\n        } else if (weekday_word == \"weekend\") {\n            // This depends on what days are weekend setting, but typically:\n            // 'This/next weekend' means the coming Saturday, 'last weekend' means last Sunday.\n            weekday = modifier == \"last\" ? Weekday.SUNDAY : Weekday.SATURDAY;\n        } else if (weekday_word == \"weekday\") {\n            // In English, the \"weekday\" means any day of the week except weekend.\n            // This also depends on what days are weekend setting, but typically:\n            // - On weekend ref, this means the coming Monday or last Friday.\n            // - On weekday ref, this means the next/last working day.\n            const refWeekday = context.reference.getDateWithAdjustedTimezone().getDay();\n            if (refWeekday == Weekday.SUNDAY || refWeekday == Weekday.SATURDAY) {\n                weekday = modifier == \"last\" ? Weekday.FRIDAY : Weekday.MONDAY;\n            } else {\n                weekday = refWeekday - 1;\n                weekday = modifier == \"last\" ? weekday - 1 : weekday + 1;\n                weekday = (weekday % 5) + 1;\n            }\n        } else {\n            return null;\n        }\n\n        return createParsingComponentsAtWeekday(context.reference, weekday, modifier);\n    }\n}\n", "import { TIME_UNIT_DICTIONARY } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport dayjs from \"dayjs\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\n\nconst PATTERN = new RegExp(\n    `(this|last|past|next|after\\\\s*this)\\\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY)})(?=\\\\s*)` + \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst MODIFIER_WORD_GROUP = 1;\nconst RELATIVE_WORD_GROUP = 2;\n\nexport default class ENRelativeDateFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();\n        const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();\n        const timeunit = TIME_UNIT_DICTIONARY[unitWord];\n\n        if (modifier == \"next\" || modifier.startsWith(\"after\")) {\n            const timeUnits = {};\n            timeUnits[timeunit] = 1;\n            return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n        }\n\n        if (modifier == \"last\" || modifier == \"past\") {\n            const timeUnits = {};\n            timeUnits[timeunit] = -1;\n            return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n        }\n\n        const components = context.createParsingComponents();\n        let date = dayjs(context.reference.instant);\n\n        // This week\n        if (unitWord.match(/week/i)) {\n            date = date.add(-date.get(\"d\"), \"d\");\n            components.imply(\"day\", date.date());\n            components.imply(\"month\", date.month() + 1);\n            components.imply(\"year\", date.year());\n        }\n\n        // This month\n        else if (unitWord.match(/month/i)) {\n            date = date.add(-date.date() + 1, \"d\");\n            components.imply(\"day\", date.date());\n            components.assign(\"year\", date.year());\n            components.assign(\"month\", date.month() + 1);\n        }\n\n        // This year\n        else if (unitWord.match(/year/i)) {\n            date = date.add(-date.date() + 1, \"d\");\n            date = date.add(-date.month(), \"month\");\n\n            components.imply(\"day\", date.date());\n            components.imply(\"month\", date.month() + 1);\n            components.assign(\"year\", date.year());\n        }\n\n        return components;\n    }\n}\n", "import { Parser, ParsingContext } from \"../../chrono\";\nimport { ParsingResult } from \"../../results\";\nimport { findMostLikelyADYear, findYearClosestToRef } from \"../../calculation/years\";\n\n/**\n * Date format with slash \"/\" (or dot \".\") between numbers.\n * For examples:\n * - 7/10\n * - 7/12/2020\n * - 7.12.2020\n */\nconst PATTERN = new RegExp(\n    \"([^\\\\d]|^)\" +\n        \"([0-3]{0,1}[0-9]{1})[\\\\/\\\\.\\\\-]([0-3]{0,1}[0-9]{1})\" +\n        \"(?:[\\\\/\\\\.\\\\-]([0-9]{4}|[0-9]{2}))?\" +\n        \"(\\\\W|$)\",\n    \"i\"\n);\n\nconst OPENING_GROUP = 1;\nconst ENDING_GROUP = 5;\n\nconst FIRST_NUMBERS_GROUP = 2;\nconst SECOND_NUMBERS_GROUP = 3;\n\nconst YEAR_GROUP = 4;\n\nexport default class SlashDateFormatParser implements Parser {\n    groupNumberMonth: number;\n    groupNumberDay: number;\n\n    constructor(littleEndian: boolean) {\n        this.groupNumberMonth = littleEndian ? SECOND_NUMBERS_GROUP : FIRST_NUMBERS_GROUP;\n        this.groupNumberDay = littleEndian ? FIRST_NUMBERS_GROUP : SECOND_NUMBERS_GROUP;\n    }\n\n    pattern(): RegExp {\n        return PATTERN;\n    }\n\n    extract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        // Because of how pattern is executed on remaining text in `chrono.ts`, the character before the match could\n        // still be a number (e.g. X[X/YY/ZZ] or XX[/YY/ZZ] or [XX/YY/]ZZ). We want to check and skip them.\n        const index = match.index + match[OPENING_GROUP].length;\n        const indexEnd = match.index + match[0].length - match[ENDING_GROUP].length;\n        if (index > 0) {\n            const textBefore = context.text.substring(0, index);\n            if (textBefore.match(\"\\\\d/?$\")) {\n                return;\n            }\n        }\n        if (indexEnd < context.text.length) {\n            const textAfter = context.text.substring(indexEnd);\n            if (textAfter.match(\"^/?\\\\d\")) {\n                return;\n            }\n        }\n\n        const text = context.text.substring(index, indexEnd);\n\n        // '1.12', '1.12.12' is more like a version numbers\n        if (text.match(/^\\d\\.\\d$/) || text.match(/^\\d\\.\\d{1,2}\\.\\d{1,2}\\s*$/)) {\n            return;\n        }\n\n        // MM/dd -> OK\n        // MM.dd -> NG\n        if (!match[YEAR_GROUP] && text.indexOf(\"/\") < 0) {\n            return;\n        }\n\n        const result = context.createParsingResult(index, text);\n        let month = parseInt(match[this.groupNumberMonth]);\n        let day = parseInt(match[this.groupNumberDay]);\n        if (month < 1 || month > 12) {\n            if (month > 12) {\n                if (day >= 1 && day <= 12 && month <= 31) {\n                    [day, month] = [month, day];\n                } else {\n                    return null;\n                }\n            }\n        }\n\n        if (day < 1 || day > 31) {\n            return null;\n        }\n\n        result.start.assign(\"day\", day);\n        result.start.assign(\"month\", month);\n\n        if (match[YEAR_GROUP]) {\n            const rawYearNumber = parseInt(match[YEAR_GROUP]);\n            const year = findMostLikelyADYear(rawYearNumber);\n            result.start.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            result.start.imply(\"year\", year);\n        }\n\n        return result.addTag(\"parser/SlashDateFormatParser\");\n    }\n}\n", "import { TIME_UNITS_PATTERN, parseTimeUnits, TIME_UNITS_NO_ABBR_PATTERN } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { reverseDuration } from \"../../../calculation/duration\";\n\nconst PATTERN = new RegExp(`(this|last|past|next|after|\\\\+|-)\\\\s*(${TIME_UNITS_PATTERN})(?=\\\\W|$)`, \"i\");\nconst PATTERN_NO_ABBR = new RegExp(\n    `(this|last|past|next|after|\\\\+|-)\\\\s*(${TIME_UNITS_NO_ABBR_PATTERN})(?=\\\\W|$)`,\n    \"i\"\n);\n\nexport default class ENTimeUnitCasualRelativeFormatParser extends AbstractParserWithWordBoundaryChecking {\n    constructor(private allowAbbreviations: boolean = true) {\n        super();\n    }\n\n    innerPattern(): RegExp {\n        return this.allowAbbreviations ? PATTERN : PATTERN_NO_ABBR;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const prefix = match[1].toLowerCase();\n        let duration = parseTimeUnits(match[2]);\n        if (!duration) {\n            return null;\n        }\n        switch (prefix) {\n            case \"last\":\n            case \"past\":\n            case \"-\":\n                duration = reverseDuration(duration);\n                break;\n        }\n        return ParsingComponents.createRelativeFromReference(context.reference, duration);\n    }\n}\n", "import { MergingRefiner } from \"../../../common/abstractRefiners\";\nimport { ParsingComponents, ParsingResult, ReferenceWithTimezone } from \"../../../results\";\nimport { parseTimeUnits } from \"../constants\";\nimport { reverseTimeUnits } from \"../../../utils/timeunits\";\n\nfunction IsPositiveFollowingReference(result: ParsingResult): boolean {\n    return result.text.match(/^[+-]/i) != null;\n}\n\nfunction IsNegativeFollowingReference(result: ParsingResult): boolean {\n    return result.text.match(/^-/i) != null;\n}\n\n/**\n * Merges a relative data/time that comes after an absolute date.\n * - [2020-02-13] [+2 weeks]\n * - [next tuesday] [+10 days]\n */\nexport default class ENMergeRelativeAfterDateRefiner extends MergingRefiner {\n    shouldMergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): boolean {\n        if (!textBetween.match(/^\\s*$/i)) {\n            return false;\n        }\n\n        return IsPositiveFollowingReference(nextResult) || IsNegativeFollowingReference(nextResult);\n    }\n\n    mergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult, context): ParsingResult {\n        let timeUnits = parseTimeUnits(nextResult.text);\n        if (IsNegativeFollowingReference(nextResult)) {\n            timeUnits = reverseTimeUnits(timeUnits);\n        }\n\n        const components = ParsingComponents.createRelativeFromReference(\n            new ReferenceWithTimezone(currentResult.start.date()),\n            timeUnits\n        );\n\n        return new ParsingResult(\n            currentResult.reference,\n            currentResult.index,\n            `${currentResult.text}${textBetween}${nextResult.text}`,\n            components\n        );\n    }\n}\n", "import { MergingRefiner } from \"../../../common/abstractRefiners\";\nimport { ParsingComponents, ParsingResult, ReferenceWithTimezone } from \"../../../results\";\nimport { parseTimeUnits } from \"../constants\";\nimport { reverseDuration } from \"../../../calculation/duration\";\n\nfunction hasImpliedEarlierReferenceDate(result: ParsingResult): boolean {\n    return result.text.match(/\\s+(before|from)$/i) != null;\n}\n\nfunction hasImpliedLaterReferenceDate(result: ParsingResult): boolean {\n    return result.text.match(/\\s+(after|since)$/i) != null;\n}\n\n/**\n * Merges a relative data/time that follow by an absolute date.\n * - [2 weeks before] [2020-02-13]\n * - [2 days after] [next Friday]\n */\nexport default class ENMergeRelativeFollowByDateRefiner extends MergingRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*$/i;\n    }\n\n    shouldMergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): boolean {\n        // Dates need to be next to each other to get merged\n        if (!textBetween.match(this.patternBetween())) {\n            return false;\n        }\n\n        // Check if any relative tokens were swallowed by the first date.\n        // E.g. [<relative_date1> from] [<date2>]\n        if (!hasImpliedEarlierReferenceDate(currentResult) && !hasImpliedLaterReferenceDate(currentResult)) {\n            return false;\n        }\n\n        // make sure that <date2> implies an absolute date\n        return !!nextResult.start.get(\"day\") && !!nextResult.start.get(\"month\") && !!nextResult.start.get(\"year\");\n    }\n\n    mergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): ParsingResult {\n        let duration = parseTimeUnits(currentResult.text);\n        if (hasImpliedEarlierReferenceDate(currentResult)) {\n            duration = reverseDuration(duration);\n        }\n\n        const components = ParsingComponents.createRelativeFromReference(\n            new ReferenceWithTimezone(nextResult.start.date()),\n            duration\n        );\n\n        return new ParsingResult(\n            nextResult.reference,\n            currentResult.index,\n            `${currentResult.text}${textBetween}${nextResult.text}`,\n            components\n        );\n    }\n}\n", "import { ParsingContext, Refiner } from \"../../../chrono\";\nimport { ParsingResult } from \"../../../results\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\n\nconst YEAR_SUFFIX_PATTERN = new RegExp(`^\\\\s*(${YEAR_PATTERN})`, \"i\");\nconst YEAR_GROUP = 1;\nexport default class ENExtractYearSuffixRefiner implements Refiner {\n    refine(context: ParsingContext, results: ParsingResult[]): ParsingResult[] {\n        results.forEach(function (result) {\n            if (!result.start.isDateWithUnknownYear()) {\n                return;\n            }\n            const suffix = context.text.substring(result.index + result.text.length);\n            const match = YEAR_SUFFIX_PATTERN.exec(suffix);\n            if (!match) {\n                return;\n            }\n            // If the suffix match is just a short number, e.g. \"14/4 90\", don't assume it year.\n            if (match[0].trim().length <= 3) {\n                return;\n            }\n            context.debug(() => {\n                console.log(`Extracting year: '${match[0]}' into : ${result}`);\n            });\n            const year = parseYear(match[YEAR_GROUP]);\n            if (result.end != null) {\n                result.end.assign(\"year\", year);\n            }\n            result.start.assign(\"year\", year);\n            result.text += match[0];\n        });\n        return results;\n    }\n}\n", "import { Filter } from \"../../../common/abstractRefiners\";\nimport { ParsingResult } from \"../../../results\";\n\nexport default class ENUnlikelyFormatFilter extends Filter {\n    constructor() {\n        super();\n    }\n\n    isValid(context, result: ParsingResult): boolean {\n        const text = result.text.trim();\n\n        // If the result is consists of the whole text (e.g. \"2024\", \"May\", etc),\n        // then it is unlikely to be a date.\n        if (text === context.text.trim()) {\n            return true;\n        }\n\n        // In English, the word \"may\" is a month name, but it is also a modal verb.\n        // Check if the text before \"may\" follows some allowed patterns.\n        if (text.toLowerCase() === \"may\") {\n            const textBefore = context.text.substring(0, result.index).trim();\n            if (!textBefore.match(/\\b(in)$/i)) {\n                context.debug(() => {\n                    console.log(`Removing unlikely result: ${result}`);\n                });\n\n                return false;\n            }\n        }\n\n        // In English, \"the second\" could refer to the ordinal number or timeunit.\n        if (text.toLowerCase().endsWith(\"the second\")) {\n            const textAfter = context.text.substring(result.index + result.text.length).trim();\n            if (textAfter.length > 0) {\n                context.debug(() => {\n                    console.log(`Removing unlikely result: ${result}`);\n                });\n            }\n            return false;\n        }\n\n        return true;\n    }\n}\n", "import { Configuration } from \"../../chrono\";\n\nimport ENTimeUnitWithinFormatParser from \"./parsers/ENTimeUnitWithinFormatParser\";\nimport ENMonthNameLittleEndianParser from \"./parsers/ENMonthNameLittleEndianParser\";\nimport ENMonthNameMiddleEndianParser from \"./parsers/ENMonthNameMiddleEndianParser\";\nimport ENMonthNameParser from \"./parsers/ENMonthNameParser\";\nimport ENYearMonthDayParser from \"./parsers/ENYearMonthDayParser\";\nimport ENSlashMonthFormatParser from \"./parsers/ENSlashMonthFormatParser\";\nimport ENTimeExpressionParser from \"./parsers/ENTimeExpressionParser\";\nimport ENTimeUnitAgoFormatParser from \"./parsers/ENTimeUnitAgoFormatParser\";\nimport ENTimeUnitLaterFormatParser from \"./parsers/ENTimeUnitLaterFormatParser\";\nimport ENMergeDateRangeRefiner from \"./refiners/ENMergeDateRangeRefiner\";\nimport ENMergeDateTimeRefiner from \"./refiners/ENMergeDateTimeRefiner\";\n\nimport { includeCommonConfiguration } from \"../../configurations\";\nimport ENCasualDateParser from \"./parsers/ENCasualDateParser\";\nimport ENCasualTimeParser from \"./parsers/ENCasualTimeParser\";\nimport ENWeekdayParser from \"./parsers/ENWeekdayParser\";\nimport ENRelativeDateFormatParser from \"./parsers/ENRelativeDateFormatParser\";\n\nimport SlashDateFormatParser from \"../../common/parsers/SlashDateFormatParser\";\nimport ENTimeUnitCasualRelativeFormatParser from \"./parsers/ENTimeUnitCasualRelativeFormatParser\";\nimport ENMergeRelativeAfterDateRefiner from \"./refiners/ENMergeRelativeAfterDateRefiner\";\nimport ENMergeRelativeFollowByDateRefiner from \"./refiners/ENMergeRelativeFollowByDateRefiner\";\nimport OverlapRemovalRefiner from \"../../common/refiners/OverlapRemovalRefiner\";\nimport ENExtractYearSuffixRefiner from \"./refiners/ENExtractYearSuffixRefiner\";\nimport ENUnlikelyFormatFilter from \"./refiners/ENUnlikelyFormatFilter\";\n\nexport default class ENDefaultConfiguration {\n    /**\n     * Create a default *casual* {@Link Configuration} for English chrono.\n     * It calls {@Link createConfiguration} and includes additional parsers.\n     */\n    createCasualConfiguration(littleEndian = false): Configuration {\n        const option = this.createConfiguration(false, littleEndian);\n        option.parsers.push(new ENCasualDateParser());\n        option.parsers.push(new ENCasualTimeParser());\n        option.parsers.push(new ENMonthNameParser());\n        option.parsers.push(new ENRelativeDateFormatParser());\n        option.parsers.push(new ENTimeUnitCasualRelativeFormatParser());\n        option.refiners.push(new ENUnlikelyFormatFilter());\n        return option;\n    }\n\n    /**\n     * Create a default {@Link Configuration} for English chrono\n     *\n     * @param strictMode If the timeunit mentioning should be strict, not casual\n     * @param littleEndian If format should be date-first/littleEndian (e.g. en_UK), not month-first/middleEndian (e.g. en_US)\n     */\n    createConfiguration(strictMode = true, littleEndian = false): Configuration {\n        const options = includeCommonConfiguration(\n            {\n                parsers: [\n                    new SlashDateFormatParser(littleEndian),\n                    new ENTimeUnitWithinFormatParser(strictMode),\n                    new ENMonthNameLittleEndianParser(),\n                    new ENMonthNameMiddleEndianParser(/*shouldSkipYearLikeDate=*/ littleEndian),\n                    new ENWeekdayParser(),\n                    new ENSlashMonthFormatParser(),\n                    new ENTimeExpressionParser(strictMode),\n                    new ENTimeUnitAgoFormatParser(strictMode),\n                    new ENTimeUnitLaterFormatParser(strictMode),\n                ],\n                refiners: [new ENMergeDateTimeRefiner()],\n            },\n            strictMode\n        );\n        options.parsers.unshift(new ENYearMonthDayParser(/*strictMonthDateOrder=*/ strictMode));\n\n        // These relative-dates consideration should be done before other common refiners.\n        options.refiners.unshift(new ENMergeRelativeFollowByDateRefiner());\n        options.refiners.unshift(new ENMergeRelativeAfterDateRefiner());\n        options.refiners.unshift(new OverlapRemovalRefiner());\n\n        // Re-apply the date time refiner again after the timezone refinement and exclusion in common refiners.\n        options.refiners.push(new ENMergeDateTimeRefiner());\n\n        // Extract year after merging date and time\n        options.refiners.push(new ENExtractYearSuffixRefiner());\n\n        // Keep the date range refiner at the end (after all other refinements).\n        options.refiners.push(new ENMergeDateRangeRefiner());\n        return options;\n    }\n}\n", "import { ReferenceWithTimezone, ParsingComponents, ParsingResult } from \"./results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference } from \"./types\";\nimport { AsyncDebugBlock, DebugHandler } from \"./debugging\";\nimport ENDefaultConfiguration from \"./locales/en/configuration\";\n\n/**\n * Chrono configuration.\n * It is simply an ordered list of parsers and refiners\n */\nexport interface Configuration {\n    parsers: Parser[];\n    refiners: Refiner[];\n}\n\n/**\n * An abstraction for Chrono *Parser*.\n *\n * Each parser should recognize and handle a certain date format.\n * Chrono uses multiple parses (and refiners) together for parsing the input.\n *\n * The parser implementation must provide {@Link pattern | pattern()} for the date format.\n *\n * The {@Link extract | extract()} method is called with the pattern's *match*.\n * The matching and extracting is controlled and adjusted to avoid for overlapping results.\n */\nexport interface Parser {\n    pattern(context: ParsingContext): RegExp;\n    extract(\n        context: ParsingContext,\n        match: RegExpMatchArray\n    ): ParsingComponents | ParsingResult | { [c in Component]?: number } | null;\n}\n\n/**\n * A abstraction for Chrono *Refiner*.\n *\n * Each refiner takes the list of results (from parsers or other refiners) and returns another list of results.\n * Chrono applies each refiner in order and return the output from the last refiner.\n */\nexport interface Refiner {\n    refine: (context: ParsingContext, results: ParsingResult[]) => ParsingResult[];\n}\n\n/**\n * The Chrono object.\n */\nexport class Chrono {\n    parsers: Array<Parser>;\n    refiners: Array<Refiner>;\n\n    defaultConfig = new ENDefaultConfiguration();\n\n    constructor(configuration?: Configuration) {\n        configuration = configuration || this.defaultConfig.createCasualConfiguration();\n        this.parsers = [...configuration.parsers];\n        this.refiners = [...configuration.refiners];\n    }\n\n    /**\n     * Create a shallow copy of the Chrono object with the same configuration (`parsers` and `refiners`)\n     */\n    clone(): Chrono {\n        return new Chrono({\n            parsers: [...this.parsers],\n            refiners: [...this.refiners],\n        });\n    }\n\n    /**\n     * A shortcut for calling {@Link parse | parse() } then transform the result into Javascript's Date object\n     * @return Date object created from the first parse result\n     */\n    parseDate(text: string, referenceDate?: ParsingReference | Date, option?: ParsingOption): Date | null {\n        const results = this.parse(text, referenceDate, option);\n        return results.length > 0 ? results[0].start.date() : null;\n    }\n\n    parse(text: string, referenceDate?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n        const context = new ParsingContext(text, referenceDate, option);\n\n        let results = [];\n        this.parsers.forEach((parser) => {\n            const parsedResults = Chrono.executeParser(context, parser);\n            results = results.concat(parsedResults);\n        });\n\n        results.sort((a, b) => {\n            return a.index - b.index;\n        });\n\n        this.refiners.forEach(function (refiner) {\n            results = refiner.refine(context, results);\n        });\n\n        return results;\n    }\n\n    private static executeParser(context: ParsingContext, parser: Parser) {\n        const results = [];\n        const pattern = parser.pattern(context);\n\n        const originalText = context.text;\n        let remainingText = context.text;\n        let match = pattern.exec(remainingText);\n\n        while (match) {\n            // Calculate match index on the full text;\n            const index = match.index + originalText.length - remainingText.length;\n            match.index = index;\n\n            const result = parser.extract(context, match);\n            if (!result) {\n                // If fails, move on by 1\n                remainingText = originalText.substring(match.index + 1);\n                match = pattern.exec(remainingText);\n                continue;\n            }\n\n            let parsedResult: ParsingResult = null;\n            if (result instanceof ParsingResult) {\n                parsedResult = result;\n            } else if (result instanceof ParsingComponents) {\n                parsedResult = context.createParsingResult(match.index, match[0]);\n                parsedResult.start = result;\n            } else {\n                parsedResult = context.createParsingResult(match.index, match[0], result);\n            }\n\n            const parsedIndex = parsedResult.index;\n            const parsedText = parsedResult.text;\n            context.debug(() =>\n                console.log(`${parser.constructor.name} extracted (at index=${parsedIndex}) '${parsedText}'`)\n            );\n\n            results.push(parsedResult);\n            remainingText = originalText.substring(parsedIndex + parsedText.length);\n            match = pattern.exec(remainingText);\n        }\n\n        return results;\n    }\n}\n\nexport class ParsingContext implements DebugHandler {\n    readonly text: string;\n    readonly option: ParsingOption;\n    readonly reference: ReferenceWithTimezone;\n\n    /**\n     * @deprecated. Use `reference.instant` instead.\n     */\n    readonly refDate: Date;\n\n    constructor(text: string, refDate?: ParsingReference | Date, option?: ParsingOption) {\n        this.text = text;\n        this.reference = new ReferenceWithTimezone(refDate);\n        this.option = option ?? {};\n\n        this.refDate = this.reference.instant;\n    }\n\n    createParsingComponents(components?: { [c in Component]?: number } | ParsingComponents): ParsingComponents {\n        if (components instanceof ParsingComponents) {\n            return components;\n        }\n\n        return new ParsingComponents(this.reference, components);\n    }\n\n    createParsingResult(\n        index: number,\n        textOrEndIndex: number | string,\n        startComponents?: { [c in Component]?: number } | ParsingComponents,\n        endComponents?: { [c in Component]?: number } | ParsingComponents\n    ): ParsingResult {\n        const text = typeof textOrEndIndex === \"string\" ? textOrEndIndex : this.text.substring(index, textOrEndIndex);\n\n        const start = startComponents ? this.createParsingComponents(startComponents) : null;\n        const end = endComponents ? this.createParsingComponents(endComponents) : null;\n\n        return new ParsingResult(this.reference, index, text, start, end);\n    }\n\n    debug(block: AsyncDebugBlock): void {\n        if (this.option.debug) {\n            if (this.option.debug instanceof Function) {\n                this.option.debug(block);\n            } else {\n                const handler: DebugHandler = <DebugHandler>this.option.debug;\n                handler.debug(block);\n            }\n        }\n    }\n}\n", "/**\n * Chrono components for English support (*parsers*, *refiners*, and *configuration*)\n *\n * @module\n */\n\nimport { Chrono, Parser, Refiner } from \"../../chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"../../results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"../../types\";\n\nimport ENDefaultConfiguration from \"./configuration\";\n\nexport { Chrono, Parser, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\nexport const configuration = new ENDefaultConfiguration();\n\n/**\n * Chrono object configured for parsing *casual* English\n */\nexport const casual = new Chrono(configuration.createCasualConfiguration(false));\n\n/**\n * Chrono object configured for parsing *strict* English\n */\nexport const strict = new Chrono(configuration.createConfiguration(true, false));\n\n/**\n * Chrono object configured for parsing *UK-style* English\n */\nexport const GB = new Chrono(configuration.createCasualConfiguration(true));\n\n/**\n * A shortcut for en.casual.parse()\n */\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\n/**\n * A shortcut for en.casual.parseDate()\n */\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date {\n    return casual.parseDate(text, ref, option);\n}\n", "import * as en from \"./locales/en\";\nimport { Chrono, Parser, ParsingContext, Refiner } from \"./chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"./results\";\nimport { Component, ParsedComponents, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"./types\";\n\nexport { en, Chrono, Parser, ParsingContext, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedComponents, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\n// Export all locales\nimport * as de from \"./locales/de\";\nimport * as fr from \"./locales/fr\";\nimport * as ja from \"./locales/ja\";\nimport * as pt from \"./locales/pt\";\nimport * as nl from \"./locales/nl\";\nimport * as zh from \"./locales/zh\";\nimport * as ru from \"./locales/ru\";\nimport * as es from \"./locales/es\";\nimport * as uk from \"./locales/uk\";\n\nexport { de, fr, ja, pt, nl, zh, ru, es, uk };\n\n/**\n * A shortcut for {@link en | chrono.en.strict}\n */\nexport const strict = en.strict;\n\n/**\n * A shortcut for {@link en | chrono.en.casual}\n */\nexport const casual = en.casual;\n\n/**\n * A shortcut for {@link en | chrono.en.casual.parse()}\n */\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\n/**\n * A shortcut for {@link en | chrono.en.casual.parseDate()}\n */\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date | null {\n    return casual.parseDate(text, ref, option);\n}\n"],
  "mappings": "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",
  "names": ["require_quarterOfYear", "__commonJSMin", "exports", "module", "t", "n", "e", "i", "r", "u", "s", "o", "require_dayjs_min", "__commonJSMin", "exports", "module", "t", "n", "r", "u", "a", "o", "f", "h", "d", "l", "$", "y", "M", "e", "m", "v", "i", "s", "g", "D", "p", "S", "_", "w", "O", "b", "c", "k", "insert_natural_language_date_exports", "__export", "insert_natural_language_date_default", "__toCommonJS", "import_api", "import_quarterOfYear", "import_dayjs", "Meridiem", "Weekday", "Month", "assignSimilarDate", "component", "target", "assignSimilarTime", "Meridiem", "implySimilarDate", "implySimilarTime", "import_dayjs", "TIMEZONE_ABBR_MAP", "year", "getLastWeekdayOfMonth", "Month", "Weekday", "getNthWeekdayOfMonth", "month", "weekday", "hour", "dayOfMonth", "i", "oneIndexedWeekday", "date", "firstWeekdayNextMonth", "dayDiff", "toTimezoneOffset", "timezoneInput", "timezoneOverrides", "matchedTimezone", "dayjs", "addDuration", "ref", "duration", "date", "floor", "remainingFraction", "reverseDuration", "reversed", "key", "dayjs", "quarterOfYear", "ReferenceWithTimezone", "input", "toTimezoneOffset", "date", "overrideTimezoneOffset", "currentTimezoneOffset", "targetTimezoneOffset", "ParsingComponents", "_ParsingComponents", "reference", "knownComponents", "key", "refDayJs", "component", "value", "timezoneAdjustment", "tag", "tags", "duration", "addDuration", "components", "assignSimilarTime", "assignSimilarDate", "implySimilarTime", "ParsingResult", "_ParsingResult", "index", "text", "start", "end", "result", "combinedTags", "repeatedTimeunitPattern", "prefix", "singleTimeunitPattern", "connectorPattern", "singleTimeunitPatternNoCapture", "extractTerms", "dictionary", "keys", "matchAnyPattern", "a", "b", "import_dayjs", "findMostLikelyADYear", "yearNumber", "findYearClosestToRef", "refDate", "day", "month", "refMoment", "dayjs", "dateMoment", "nextYear", "lastYear", "WEEKDAY_DICTIONARY", "FULL_MONTH_NAME_DICTIONARY", "MONTH_DICTIONARY", "INTEGER_WORD_DICTIONARY", "ORDINAL_WORD_DICTIONARY", "TIME_UNIT_DICTIONARY_NO_ABBR", "TIME_UNIT_DICTIONARY", "NUMBER_PATTERN", "matchAnyPattern", "parseNumberPattern", "match", "num", "ORDINAL_NUMBER_PATTERN", "parseOrdinalNumberPattern", "YEAR_PATTERN", "parseYear", "rawYearNumber", "findMostLikelyADYear", "SINGLE_TIME_UNIT_PATTERN", "SINGLE_TIME_UNIT_REGEX", "SINGLE_TIME_UNIT_NO_ABBR_PATTERN", "TIME_UNIT_CONNECTOR_PATTERN", "TIME_UNITS_PATTERN", "repeatedTimeunitPattern", "TIME_UNITS_NO_ABBR_PATTERN", "parseTimeUnits", "timeunitText", "fragments", "remainingText", "collectDateTimeFragment", "unit", "AbstractParserWithWordBoundaryChecking", "context", "currentInnerPattern", "match", "header", "PATTERN_WITH_OPTIONAL_PREFIX", "TIME_UNITS_PATTERN", "PATTERN_WITH_PREFIX", "PATTERN_WITH_PREFIX_STRICT", "TIME_UNITS_NO_ABBR_PATTERN", "ENTimeUnitWithinFormatParser", "AbstractParserWithWordBoundaryChecking", "strictMode", "context", "match", "timeUnits", "parseTimeUnits", "ParsingComponents", "PATTERN", "ORDINAL_NUMBER_PATTERN", "matchAnyPattern", "MONTH_DICTIONARY", "YEAR_PATTERN", "DATE_GROUP", "DATE_TO_GROUP", "MONTH_NAME_GROUP", "YEAR_GROUP", "ENMonthNameLittleEndianParser", "AbstractParserWithWordBoundaryChecking", "context", "match", "result", "month", "day", "parseOrdinalNumberPattern", "yearNumber", "parseYear", "year", "findYearClosestToRef", "endDate", "PATTERN", "matchAnyPattern", "MONTH_DICTIONARY", "ORDINAL_NUMBER_PATTERN", "YEAR_PATTERN", "MONTH_NAME_GROUP", "DATE_GROUP", "DATE_TO_GROUP", "YEAR_GROUP", "ENMonthNameMiddleEndianParser", "AbstractParserWithWordBoundaryChecking", "shouldSkipYearLikeDate", "context", "match", "month", "day", "parseOrdinalNumberPattern", "components", "year", "parseYear", "findYearClosestToRef", "endDate", "result", "PATTERN", "matchAnyPattern", "MONTH_DICTIONARY", "YEAR_PATTERN", "PREFIX_GROUP", "MONTH_NAME_GROUP", "YEAR_GROUP", "ENMonthNameParser", "AbstractParserWithWordBoundaryChecking", "context", "match", "monthName", "FULL_MONTH_NAME_DICTIONARY", "result", "month", "year", "parseYear", "findYearClosestToRef", "PATTERN", "matchAnyPattern", "MONTH_DICTIONARY", "YEAR_NUMBER_GROUP", "MONTH_NAME_GROUP", "MONTH_NUMBER_GROUP", "DATE_NUMBER_GROUP", "ENYearMonthDayParser", "AbstractParserWithWordBoundaryChecking", "strictMonthDateOrder", "context", "match", "year", "day", "month", "PATTERN", "MONTH_GROUP", "YEAR_GROUP", "ENSlashMonthFormatParser", "AbstractParserWithWordBoundaryChecking", "context", "match", "year", "month", "primaryTimePattern", "leftBoundary", "primaryPrefix", "primarySuffix", "flags", "followingTimePatten", "followingPhase", "followingSuffix", "HOUR_GROUP", "MINUTE_GROUP", "SECOND_GROUP", "MILLI_SECOND_GROUP", "AM_PM_HOUR_GROUP", "AbstractTimeExpressionParser", "strictMode", "context", "match", "startComponents", "index", "text", "result", "remainingText", "followingMatch", "strict", "components", "minute", "meridiem", "hour", "Meridiem", "ampm", "millisecond", "second", "endingWithNumbers", "endingNumbers", "startingNumbers", "endingNumberVal", "startingNumberVal", "ENTimeExpressionParser", "AbstractTimeExpressionParser", "strictMode", "context", "match", "components", "hour", "Meridiem", "result", "followingComponents", "PATTERN", "TIME_UNITS_PATTERN", "STRICT_PATTERN", "TIME_UNITS_NO_ABBR_PATTERN", "ENTimeUnitAgoFormatParser", "AbstractParserWithWordBoundaryChecking", "strictMode", "context", "match", "duration", "parseTimeUnits", "ParsingComponents", "reverseDuration", "PATTERN", "TIME_UNITS_PATTERN", "STRICT_PATTERN", "TIME_UNITS_NO_ABBR_PATTERN", "GROUP_NUM_TIMEUNITS", "ENTimeUnitLaterFormatParser", "AbstractParserWithWordBoundaryChecking", "strictMode", "context", "match", "timeUnits", "parseTimeUnits", "ParsingComponents", "Filter", "context", "results", "r", "MergingRefiner", "mergedResults", "curResult", "nextResult", "i", "textBetween", "left", "right", "mergedResult", "AbstractMergeDateRangeRefiner", "MergingRefiner", "textBetween", "currentResult", "nextResult", "fromResult", "toResult", "key", "fromMoment", "toMoment", "result", "ENMergeDateRangeRefiner", "AbstractMergeDateRangeRefiner", "implyTheNextDay", "component", "targetDayJs", "implySimilarDate", "implySimilarTime", "assignSimilarDate", "assignSimilarTime", "Meridiem", "mergeDateTimeResult", "dateResult", "timeResult", "result", "beginDate", "beginTime", "mergeDateTimeComponent", "endDate", "endTime", "endDateTime", "nextDayJs", "assignSimilarDate", "implySimilarDate", "dateComponent", "timeComponent", "dateTimeComponent", "Meridiem", "AbstractMergeDateTimeRefiner", "MergingRefiner", "textBetween", "currentResult", "nextResult", "result", "mergeDateTimeResult", "ENMergeDateTimeRefiner", "AbstractMergeDateTimeRefiner", "TIMEZONE_NAME_PATTERN", "ExtractTimezoneAbbrRefiner", "timezoneOverrides", "context", "results", "result", "suffix", "match", "timezoneAbbr", "refDate", "tzOverrides", "extractedTimezoneOffset", "toTimezoneOffset", "currentTimezoneOffset", "TIMEZONE_OFFSET_PATTERN", "TIMEZONE_OFFSET_SIGN_GROUP", "TIMEZONE_OFFSET_HOUR_OFFSET_GROUP", "TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP", "ExtractTimezoneOffsetRefiner", "context", "results", "result", "suffix", "match", "hourOffset", "minuteOffset", "timezoneOffset", "OverlapRemovalRefiner", "context", "results", "filteredResults", "prevResult", "i", "result", "kept", "removed", "import_dayjs", "ForwardDateRefiner", "context", "results", "result", "refMoment", "dayjs", "refDate", "refFollowingDay", "implySimilarDate", "i", "UnlikelyFormatFilter", "Filter", "strictMode", "context", "result", "PATTERN", "YEAR_NUMBER_GROUP", "MONTH_NUMBER_GROUP", "DATE_NUMBER_GROUP", "HOUR_NUMBER_GROUP", "MINUTE_NUMBER_GROUP", "SECOND_NUMBER_GROUP", "MILLISECOND_NUMBER_GROUP", "TZD_GROUP", "TZD_HOUR_OFFSET_GROUP", "TZD_MINUTE_OFFSET_GROUP", "ISOFormatParser", "AbstractParserWithWordBoundaryChecking", "context", "match", "components", "offset", "hourOffset", "minuteOffset", "MergeWeekdayComponentRefiner", "MergingRefiner", "textBetween", "currentResult", "nextResult", "newResult", "includeCommonConfiguration", "configuration", "strictMode", "ISOFormatParser", "MergeWeekdayComponentRefiner", "ExtractTimezoneOffsetRefiner", "OverlapRemovalRefiner", "ExtractTimezoneAbbrRefiner", "ForwardDateRefiner", "UnlikelyFormatFilter", "import_dayjs", "import_dayjs", "now", "reference", "targetDate", "dayjs", "component", "ParsingComponents", "assignSimilarDate", "assignSimilarTime", "today", "implySimilarTime", "yesterday", "theDayBefore", "numDay", "theDayAfter", "tomorrow", "nDays", "tonight", "implyHour", "Meridiem", "evening", "reference", "implyHour", "component", "ParsingComponents", "Meridiem", "midnight", "reference", "component", "ParsingComponents", "targetDate", "dayjs", "implyTheNextDay", "morning", "implyHour", "Meridiem", "afternoon", "noon", "PATTERN", "ENCasualDateParser", "AbstractParserWithWordBoundaryChecking", "context", "match", "targetDate", "dayjs", "lowerText", "component", "now", "today", "yesterday", "tomorrow", "tonight", "theDayAfter", "assignSimilarDate", "PATTERN", "ENCasualTimeParser", "AbstractParserWithWordBoundaryChecking", "context", "match", "component", "afternoon", "evening", "midnight", "morning", "noon", "reverseTimeUnits", "timeUnits", "reversed", "key", "addImpliedTimeUnits", "components", "output", "date", "createParsingComponentsAtWeekday", "reference", "weekday", "modifier", "refDate", "daysToWeekday", "getDaysToWeekday", "components", "ParsingComponents", "addImpliedTimeUnits", "refWeekday", "getDaysForwardToWeekday", "getBackwardDaysToWeekday", "Weekday", "getDaysToWeekdayClosest", "backward", "forward", "forwardCount", "backwardCount", "PATTERN", "matchAnyPattern", "WEEKDAY_DICTIONARY", "PREFIX_GROUP", "WEEKDAY_GROUP", "POSTFIX_GROUP", "ENWeekdayParser", "AbstractParserWithWordBoundaryChecking", "context", "match", "prefix", "postfix", "modifierWord", "modifier", "weekday_word", "weekday", "Weekday", "refWeekday", "createParsingComponentsAtWeekday", "import_dayjs", "PATTERN", "matchAnyPattern", "TIME_UNIT_DICTIONARY", "MODIFIER_WORD_GROUP", "RELATIVE_WORD_GROUP", "ENRelativeDateFormatParser", "AbstractParserWithWordBoundaryChecking", "context", "match", "modifier", "unitWord", "timeunit", "timeUnits", "ParsingComponents", "components", "date", "dayjs", "PATTERN", "OPENING_GROUP", "ENDING_GROUP", "FIRST_NUMBERS_GROUP", "SECOND_NUMBERS_GROUP", "YEAR_GROUP", "SlashDateFormatParser", "littleEndian", "context", "match", "index", "indexEnd", "text", "result", "month", "day", "rawYearNumber", "year", "findMostLikelyADYear", "findYearClosestToRef", "PATTERN", "TIME_UNITS_PATTERN", "PATTERN_NO_ABBR", "TIME_UNITS_NO_ABBR_PATTERN", "ENTimeUnitCasualRelativeFormatParser", "AbstractParserWithWordBoundaryChecking", "allowAbbreviations", "context", "match", "prefix", "duration", "parseTimeUnits", "reverseDuration", "ParsingComponents", "IsPositiveFollowingReference", "result", "IsNegativeFollowingReference", "ENMergeRelativeAfterDateRefiner", "MergingRefiner", "textBetween", "currentResult", "nextResult", "context", "timeUnits", "parseTimeUnits", "reverseTimeUnits", "components", "ParsingComponents", "ReferenceWithTimezone", "ParsingResult", "hasImpliedEarlierReferenceDate", "result", "hasImpliedLaterReferenceDate", "ENMergeRelativeFollowByDateRefiner", "MergingRefiner", "textBetween", "currentResult", "nextResult", "duration", "parseTimeUnits", "reverseDuration", "components", "ParsingComponents", "ReferenceWithTimezone", "ParsingResult", "YEAR_SUFFIX_PATTERN", "YEAR_PATTERN", "YEAR_GROUP", "ENExtractYearSuffixRefiner", "context", "results", "result", "suffix", "match", "year", "parseYear", "ENUnlikelyFormatFilter", "Filter", "context", "result", "text", "ENDefaultConfiguration", "littleEndian", "option", "ENCasualDateParser", "ENCasualTimeParser", "ENMonthNameParser", "ENRelativeDateFormatParser", "ENTimeUnitCasualRelativeFormatParser", "ENUnlikelyFormatFilter", "strictMode", "options", "includeCommonConfiguration", "SlashDateFormatParser", "ENTimeUnitWithinFormatParser", "ENMonthNameLittleEndianParser", "ENMonthNameMiddleEndianParser", "ENWeekdayParser", "ENSlashMonthFormatParser", "ENTimeExpressionParser", "ENTimeUnitAgoFormatParser", "ENTimeUnitLaterFormatParser", "ENMergeDateTimeRefiner", "ENYearMonthDayParser", "ENMergeRelativeFollowByDateRefiner", "ENMergeRelativeAfterDateRefiner", "OverlapRemovalRefiner", "ENExtractYearSuffixRefiner", "ENMergeDateRangeRefiner", "Chrono", "_Chrono", "ENDefaultConfiguration", "configuration", "text", "referenceDate", "option", "results", "context", "ParsingContext", "parser", "parsedResults", "b", "refiner", "pattern", "originalText", "remainingText", "match", "index", "result", "parsedResult", "ParsingResult", "ParsingComponents", "parsedIndex", "parsedText", "refDate", "ReferenceWithTimezone", "components", "textOrEndIndex", "startComponents", "endComponents", "start", "end", "block", "configuration", "ENDefaultConfiguration", "casual", "Chrono", "strict", "GB", "casual", "parseDate", "text", "ref", "option", "casual", "import_dayjs", "isValidFormat", "format", "validTokens", "stripped", "str", "token", "InsertNaturalLanguageDate", "props", "prompt", "parsed", "parseDate", "formatted", "dayjs", "insert_natural_language_date_default"]
}
